 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF'
diff --git a/docs/config_tuning.md b/docs/config_tuning.md
new file mode 100644
index 0000000000000000000000000000000000000000..7384e66ae9c25fd83e8e58afc980a126dfb7e2b4
--- /dev/null
+++ b/docs/config_tuning.md
@@ -0,0 +1,38 @@
+# Configuration Tuning Guide
+
+Use this guide to adjust runtime parameters safely.
+
+## Retrieval Fusion Weights
+
+1. Update `retrieval.fusion.weights` in `config-override.yaml` or the environment-specific file.
+2. Run `med config validate --strict` to confirm the weights sum to 1.0.
+3. POST to `/admin/reload` (see [Hot Reload](hot_reload.md)) to apply the change without restarting.
+4. Monitor the `feature_flag` and `config_info` metrics to verify rollout.
+
+If SPLADE is disabled (`feature_flags.splade_enabled = false`), weights are redistributed between BM25 and dense automatically.
+
+## Chunking Profiles
+
+- Increase `target_tokens` to produce fewer, longer chunks. Maintain `overlap` at least 5–10% of `target_tokens` for continuity.
+- Adjust `tau_coh` upwards to enforce tighter semantic coherence; lower values create more aggressive splitting.
+- After editing, validate and hot reload to propagate.
+
+## Rate Limits
+
+`apis.rate_limits` and `sources.*.rate_limit` follow the same structure. Ensure `burst` is at least 25% of `requests_per_minute` to avoid throttling short bursts. Apply overrides and hot reload to update in place.
+
+## Logging Levels
+
+`observability.logging.level` accepts `debug`, `info`, `warn`, or `error`.
+
+- Use `debug` in development for verbose traces.
+- Prefer `info` or `warn` in staging/production.
+- Hot reload applies the new level immediately.
+
+## Feature Flags
+
+Toggle flags under `feature_flags`. The loader emits a `feature_flag{name="..."}` gauge (1 enabled, 0 disabled) for observability.
+
+## Licensing Gates
+
+Before enabling a vocabulary in `catalog.vocabs`, confirm `policy.yaml` marks it as `licensed: true`. Validation fails if a required license is missing.
diff --git a/docs/configuration.md b/docs/configuration.md
new file mode 100644
index 0000000000000000000000000000000000000000..6e6986558ff4f2cd664c9cc5bede024ebdc95514
--- /dev/null
+++ b/docs/configuration.md
@@ -0,0 +1,71 @@
+# Medical KG Configuration Overview
+
+This document describes the structure of `config.yaml` and the companion files that drive runtime behaviour.
+
+## File Layout
+
+| File | Purpose |
+| --- | --- |
+| `config.yaml` | Base configuration shared by every environment. |
+| `config-dev.yaml` | Local development overrides (mock credentials, verbose logging). |
+| `config-staging.yaml` | Staging overrides using non-production credentials. |
+| `config-prod.yaml` | Production overrides with strict rate limits and licensing gates. |
+| `config-override.yaml` | Optional, not committed – developer specific overrides applied last. |
+| `policy.yaml` | Licensing decisions for vocabularies and enforcement actions. |
+
+At runtime the loader merges the files in the order above and applies environment variables (highest precedence).
+
+## Section Reference
+
+### `feature_flags`
+
+Toggle experimental systems such as SPLADE retrieval or extraction pipelines. Flags are evaluated on hot reload so they can be toggled without a full restart.
+
+### `sources`
+
+Defines upstream connectors. Every source entry contains:
+
+- `base_url` – service endpoint.
+- `api_key` – secret placeholder resolved from Vault/env.
+- `rate_limit` – request throttle (requests per minute and burst capacity).
+- `retry` – transient retry policy (attempt count + base back-off seconds).
+
+### `chunking`
+
+Profiles with token and coherence controls for document segmentation. `target_tokens` must be greater than 0 and `overlap` must be less than `target_tokens`.
+
+### `embeddings`
+
+Parameters for the vLLM embedding service (base URL, model name, GPU enforcement) and SPLADE pruning behaviour.
+
+### `retrieval`
+
+Fusion strategy, reranker policy, and neighbour merge heuristics. Fusion weights must sum to 1.0 and are re-balanced automatically if SPLADE is disabled.
+
+### `extraction`
+
+LLM extractor prompts grouped by intent. Each extractor sets the downstream intent (`pico`, `endpoint`, `ae`, `dose`, `eligibility`, or `general`), temperature, max tokens, and a confidence threshold.
+
+### `kg`
+
+Neo4j connectivity and SHACL enforcement toggle. Credentials are supplied via placeholders and resolved at load time.
+
+### `catalog`
+
+Vocabulary ingestion options with refresh cadence and licensing requirements. Each vocabulary references `policy.yaml` to ensure appropriate licensing before import.
+
+### `apis`
+
+API rate limits per scope, JWT authentication details, and CORS allow-list. The `admin_scope` controls access to the reload endpoint.
+
+### `observability`
+
+Logging level (enum: `debug`, `info`, `warn`, `error`), Prometheus push interval, and OpenTelemetry tracing endpoint/sample rate.
+
+### `licensing`
+
+Pointer to the policy file used to gate vocab ingestion and runtime responses.
+
+## Environment Selection
+
+Set `CONFIG_ENV` to `dev`, `staging`, or `prod` to apply the matching overlay file. If unset the loader defaults to `dev` for developer friendliness.
diff --git a/docs/hot_reload.md b/docs/hot_reload.md
new file mode 100644
index 0000000000000000000000000000000000000000..d405f58100983650ee3f0b53fc74ec82673a48df
--- /dev/null
+++ b/docs/hot_reload.md
@@ -0,0 +1,50 @@
+# Hot Reload Procedure
+
+The `/admin/reload` endpoint applies non-breaking configuration updates without a service restart.
+
+## Prerequisites
+
+- Valid admin JWT containing the `admin:config` scope.
+- Updated configuration files (`config.yaml`, environment overlay, and/or `config-override.yaml`).
+- Successful run of `med config validate --strict`.
+
+## Steps
+
+1. Ensure `CONFIG_ENV` is set to the target environment on the running service.
+2. Apply file changes and commit to version control (optional but recommended).
+3. Issue the reload request:
+
+```bash
+curl -X POST \
+  -H "Authorization: Bearer <token>" \
+  https://<host>/admin/reload
+```
+
+4. On success the API returns:
+
+```json
+{ "config_version": "2024-06-01T12:00:00+0000+abc123456789", "hash": "..." }
+```
+
+5. Watch the `config_info` metric for the new version/hash pair.
+
+## Breaking Changes
+
+The loader rejects changes to `embeddings.vllm_api_base` and `kg.neo4j_uri` during hot reload. When these fields change the endpoint returns HTTP 400 with the message `Breaking change requires restart`. Restart the service with the updated configuration to proceed.
+
+## Safe Changes
+
+The following settings can be applied via hot reload:
+
+- Retrieval fusion weights and reranker toggles.
+- API and source rate limits.
+- Feature flags.
+- Logging level and metrics push interval.
+
+## Validation on Reload
+
+Every reload re-runs schema validation, Pydantic model validation, and licensing checks. The payload is rejected if:
+
+- Fusion weights do not sum to ~1.0.
+- Chunking profiles use invalid token counts.
+- A vocabulary requiring a license is enabled without authorization in `policy.yaml`.
diff --git a/docs/secrets_management.md b/docs/secrets_management.md
new file mode 100644
index 0000000000000000000000000000000000000000..27b59f2a817074912d2fe6279cbcbbdf37b8bd51
--- /dev/null
+++ b/docs/secrets_management.md
@@ -0,0 +1,25 @@
+# Secrets Management
+
+Configuration files never contain raw secrets. Fields such as `api_key`, `jwt_secret`, and `password` use `${VAR_NAME}` placeholders.
+
+## Resolution Order
+
+1. Environment variables passed to the process.
+2. Values returned by the injected `SecretResolver` (Vault/KMS adapter).
+3. Optional default specified as `${VAR_NAME:default}`.
+
+If a required secret cannot be resolved the loader raises `Missing required secret: <NAME>` and the service fails fast.
+
+## Usage Patterns
+
+- **Environment variables**: export secrets before running the service (`export API_JWT_SECRET=...`).
+- **Vault/KMS**: extend `SecretResolver` to call your secret store and pass it to `ConfigManager(secret_resolver=...)`.
+- **Overrides**: use `config-override.yaml` for local development with dummy credentials and avoid committing the file.
+
+## Masking
+
+Commands that display configuration (`med config show`) mask keys ending in `_key`, `_secret`, `_token`, or `password`. Placeholder strings that still contain `${...}` are also masked.
+
+## Logging
+
+Never log resolved secrets. The loader masks sensitive values when serialising configurations for debugging.
diff --git a/openspec/changes/01-add-config-management/tasks.md b/openspec/changes/01-add-config-management/tasks.md
index 31a8a6617447fcecebd6028a300c78d74a572593..7b718cdc7708c0b6013db4f0a165c111304ad3f6 100644
--- a/openspec/changes/01-add-config-management/tasks.md
+++ b/openspec/changes/01-add-config-management/tasks.md
@@ -1,90 +1,90 @@
 # Implementation Tasks

 ## 1. Master config.yaml Structure

-- [ ] 1.1 Define sources section (api_keys, rate_limits, retry_configs per source)
-- [ ] 1.2 Define chunking section (profiles: IMRaD/Registry/SPL/Guideline with target_tokens, overlap, tau_coh)
-- [ ] 1.3 Define embeddings section (vllm_api_base, batch_size, splade_top_k, require_gpu)
-- [ ] 1.4 Define retrieval section (fusion weights, rrf_k, reranker enabled/topN, neighbor_merge min_cosine/max_tokens)
-- [ ] 1.5 Define extraction section (per-extractor prompts, temperature, max_tokens, confidence_threshold)
-- [ ] 1.6 Define kg section (neo4j_uri, batch_size, shacl_enabled)
-- [ ] 1.7 Define catalog section (update schedules per ontology, license gates)
-- [ ] 1.8 Define apis section (rate_limits per scope, auth config, cors origins)
-- [ ] 1.9 Define observability section (log level, metrics push_interval, tracing sample_rate)
-- [ ] 1.10 Define licensing section (pointer to policy.yaml)
+- [x] 1.1 Define sources section (api_keys, rate_limits, retry_configs per source)
+- [x] 1.2 Define chunking section (profiles: IMRaD/Registry/SPL/Guideline with target_tokens, overlap, tau_coh)
+- [x] 1.3 Define embeddings section (vllm_api_base, batch_size, splade_top_k, require_gpu)
+- [x] 1.4 Define retrieval section (fusion weights, rrf_k, reranker enabled/topN, neighbor_merge min_cosine/max_tokens)
+- [x] 1.5 Define extraction section (per-extractor prompts, temperature, max_tokens, confidence_threshold)
+- [x] 1.6 Define kg section (neo4j_uri, batch_size, shacl_enabled)
+- [x] 1.7 Define catalog section (update schedules per ontology, license gates)
+- [x] 1.8 Define apis section (rate_limits per scope, auth config, cors origins)
+- [x] 1.9 Define observability section (log level, metrics push_interval, tracing sample_rate)
+- [x] 1.10 Define licensing section (pointer to policy.yaml)

 ## 2. config.schema.json

-- [ ] 2.1 Define JSON Schema for all config sections
-- [ ] 2.2 Add constraints (e.g., retrieval fusion weights must sum to 1.0; chunking target_tokens > 0)
-- [ ] 2.3 Add enums (log_level: debug/info/warn/error; intent: pico/endpoint/ae/dose/eligibility/general)
-- [ ] 2.4 Add descriptions for each field
+- [x] 2.1 Define JSON Schema for all config sections
+- [x] 2.2 Add constraints (e.g., retrieval fusion weights must sum to 1.0; chunking target_tokens > 0)
+- [x] 2.3 Add enums (log_level: debug/info/warn/error; intent: pico/endpoint/ae/dose/eligibility/general)
+- [x] 2.4 Add descriptions for each field

 ## 3. policy.yaml (Licensing)

-- [ ] 3.1 Define vocabs section (SNOMED{licensed, territory}, MedDRA{licensed}, LOINC{licensed}, RxNorm{licensed}, HPO{licensed})
-- [ ] 3.2 Define actions section (redact_unlicensed_codes, block_kg_write_without_provenance)
-- [ ] 3.3 Validate on startup (if vocab used but not licensed → fail or warn)
+- [x] 3.1 Define vocabs section (SNOMED{licensed, territory}, MedDRA{licensed}, LOINC{licensed}, RxNorm{licensed}, HPO{licensed})
+- [x] 3.2 Define actions section (redact_unlicensed_codes, block_kg_write_without_provenance)
+- [x] 3.3 Validate on startup (if vocab used but not licensed → fail or warn)

 ## 4. Hierarchical Overrides

-- [ ] 4.1 Load config.yaml (base)
-- [ ] 4.2 Overlay config-override.yaml if present (dev/test overrides)
-- [ ] 4.3 Overlay env vars (e.g., VLLM_API_BASE, RETRIEVAL_FUSION_WEIGHTS)
-- [ ] 4.4 Final config = base + overrides + env vars
+- [x] 4.1 Load config.yaml (base)
+- [x] 4.2 Overlay config-override.yaml if present (dev/test overrides)
+- [x] 4.3 Overlay env vars (e.g., VLLM_API_BASE, RETRIEVAL_FUSION_WEIGHTS)
+- [x] 4.4 Final config = base + overrides + env vars

 ## 5. Validation

-- [ ] 5.1 Implement config validator (load YAML; validate against schema; check constraints)
-- [ ] 5.2 Create CLI `med config validate --strict` (fail on any error/warning)
-- [ ] 5.3 Run validation on startup (fail-fast if invalid)
-- [ ] 5.4 Run validation before hot-reload (reject if invalid)
+- [x] 5.1 Implement config validator (load YAML; validate against schema; check constraints)
+- [x] 5.2 Create CLI `med config validate --strict` (fail on any error/warning)
+- [x] 5.3 Run validation on startup (fail-fast if invalid)
+- [x] 5.4 Run validation before hot-reload (reject if invalid)

 ## 6. Hot-Reload

-- [ ] 6.1 Implement POST /admin/reload endpoint (requires admin scope + signed JWT)
-- [ ] 6.2 Re-read config files (config.yaml + config-override.yaml + env vars)
-- [ ] 6.3 Validate new config
-- [ ] 6.4 Apply non-breaking changes (e.g., retrieval weights, log level, rate limits) without restart
-- [ ] 6.5 Reject breaking changes (e.g., vllm_api_base, neo4j_uri) with clear error
-- [ ] 6.6 Increment config_version; emit metric
+- [x] 6.1 Implement POST /admin/reload endpoint (requires admin scope + signed JWT)
+- [x] 6.2 Re-read config files (config.yaml + config-override.yaml + env vars)
+- [x] 6.3 Validate new config
+- [x] 6.4 Apply non-breaking changes (e.g., retrieval weights, log level, rate limits) without restart
+- [x] 6.5 Reject breaking changes (e.g., vllm_api_base, neo4j_uri) with clear error
+- [x] 6.6 Increment config_version; emit metric

 ## 7. Feature Flags

-- [ ] 7.1 Define feature_flags section in config (splade_enabled, reranker_enabled, extraction_experimental_enabled)
-- [ ] 7.2 Check flags at runtime (if !splade_enabled → skip SPLADE retriever; adjust fusion weights)
-- [ ] 7.3 Emit metrics with flag states (feature_flag{name, enabled})
+- [x] 7.1 Define feature_flags section in config (splade_enabled, reranker_enabled, extraction_experimental_enabled)
+- [x] 7.2 Check flags at runtime (if !splade_enabled → skip SPLADE retriever; adjust fusion weights)
+- [x] 7.3 Emit metrics with flag states (feature_flag{name, enabled})

 ## 8. Config Versioning

-- [ ] 8.1 Compute config_hash (SHA256 of canonical YAML)
-- [ ] 8.2 Store config_version (semantic version or timestamp + hash)
-- [ ] 8.3 Emit config_version as metric (config_info{version, hash})
-- [ ] 8.4 Log config_version on startup and after reload
+- [x] 8.1 Compute config_hash (SHA256 of canonical YAML)
+- [x] 8.2 Store config_version (semantic version or timestamp + hash)
+- [x] 8.3 Emit config_version as metric (config_info{version, hash})
+- [x] 8.4 Log config_version on startup and after reload

 ## 9. Environment-Specific Configs

-- [ ] 9.1 Create config-dev.yaml (local dev; mock APIs; verbose logging)
-- [ ] 9.2 Create config-staging.yaml (staging; real APIs with test keys)
-- [ ] 9.3 Create config-prod.yaml (production; secrets from Vault; strict licensing)
-- [ ] 9.4 Use CONFIG_ENV env var to select environment
+- [x] 9.1 Create config-dev.yaml (local dev; mock APIs; verbose logging)
+- [x] 9.2 Create config-staging.yaml (staging; real APIs with test keys)
+- [x] 9.3 Create config-prod.yaml (production; secrets from Vault; strict licensing)
+- [x] 9.4 Use CONFIG_ENV env var to select environment

 ## 10. Secrets Management

-- [ ] 10.1 Do NOT store secrets in config.yaml (use placeholders like ${UMLS_API_KEY})
-- [ ] 10.2 Resolve placeholders from Vault/KMS at runtime
-- [ ] 10.3 Mask secrets in logs and error messages
+- [x] 10.1 Do NOT store secrets in config.yaml (use placeholders like ${UMLS_API_KEY})
+- [x] 10.2 Resolve placeholders from Vault/KMS at runtime
+- [x] 10.3 Mask secrets in logs and error messages

 ## 11. Testing

-- [ ] 11.1 Unit tests for config loading (base + overrides + env vars)
-- [ ] 11.2 Unit tests for validation (valid config passes; invalid config fails with clear errors)
-- [ ] 11.3 Integration test hot-reload (change retrieval weights; verify new weights used; verify config_version incremented)
-- [ ] 11.4 Test feature flags (disable SPLADE → verify SPLADE skipped; fusion weights auto-adjusted)
+- [x] 11.1 Unit tests for config loading (base + overrides + env vars)
+- [x] 11.2 Unit tests for validation (valid config passes; invalid config fails with clear errors)
+- [x] 11.3 Integration test hot-reload (change retrieval weights; verify new weights used; verify config_version incremented)
+- [x] 11.4 Test feature flags (disable SPLADE → verify SPLADE skipped; fusion weights auto-adjusted)

 ## 12. Documentation

-- [ ] 12.1 Document config.yaml structure with examples
-- [ ] 12.2 Create config tuning guide (common adjustments: retrieval weights, chunking profiles, rate limits)
-- [ ] 12.3 Document hot-reload procedure (when safe; when requires restart)
-- [ ] 12.4 Document secrets management (Vault integration, placeholder syntax)
+- [x] 12.1 Document config.yaml structure with examples
+- [x] 12.2 Create config tuning guide (common adjustments: retrieval weights, chunking profiles, rate limits)
+- [x] 12.3 Document hot-reload procedure (when safe; when requires restart)
+- [x] 12.4 Document secrets management (Vault integration, placeholder syntax)
diff --git a/openspec/changes/02-add-data-ingestion-core/tasks.md b/openspec/changes/02-add-data-ingestion-core/tasks.md
index 5b0b95a523e5c96de632f1e67059512cbe1601cd..e56c8f9a9985171d5f6007448451ef0b30bd321a 100644
--- a/openspec/changes/02-add-data-ingestion-core/tasks.md
+++ b/openspec/changes/02-add-data-ingestion-core/tasks.md
@@ -1,34 +1,34 @@
 # Implementation Tasks

 ## 1. Foundation

-- [ ] 1.1 Create HTTP client with retries, rate limiting, per-host throttling (`connectors/http_client.py`)
-- [ ] 1.2 Implement ledger system (states: pdf_downloaded, auto_inflight, auto_done, *_failed) with JSONL persistence
-- [ ] 1.3 Create base Adapter interface (`fetch`, `parse`, `validate`, `write`)
-- [ ] 1.4 Implement content hashing (SHA256) and doc_id generation (`{source}:{id}#{version}:{hash12}`)
-- [ ] 1.5 Create normalization utilities (UTF-8, NFKC, whitespace, de-hyphenation, language detection)
+- [x] 1.1 Create HTTP client with retries, rate limiting, per-host throttling (`connectors/http_client.py`)
+- [x] 1.2 Implement ledger system (states: pdf_downloaded, auto_inflight, auto_done, *_failed) with JSONL persistence
+- [x] 1.3 Create base Adapter interface (`fetch`, `parse`, `validate`, `write`)
+- [x] 1.4 Implement content hashing (SHA256) and doc_id generation (`{source}:{id}#{version}:{hash12}`)
+- [x] 1.5 Create normalization utilities (UTF-8, NFKC, whitespace, de-hyphenation, language detection)
 - [ ] 1.6 Add test fixtures for each source (sample responses)

 ## 2. Literature & Preprints

 - [ ] 2.1 Implement PubMed E-utilities adapter (ESearch, EFetch, ESummary with usehistory paging)
 - [ ] 2.2 Implement PMC OAI-PMH adapter (ListRecords with resumptionToken)
 - [ ] 2.3 Implement medRxiv adapter (details endpoint with cursor paging)
 - [ ] 2.4 Add rate limit handling (3 rps → 10 rps with API key for NCBI)

 ## 3. Clinical Trials

 - [ ] 3.1 Implement ClinicalTrials.gov v2 adapter (search_studies, get_study with pageToken)
 - [ ] 3.2 Parse protocol sections (eligibility, outcome measures, arms, results, AEs)
 - [ ] 3.3 Store record_version for change tracking
 - [ ] 3.4 Add validation for NCT ID format

 ## 4. Drug & Device Safety

 - [ ] 4.1 Implement openFDA adapter (FAERS /drug/event, MAUDE /device/event, Labels, NDC)
 - [ ] 4.2 Handle Elasticsearch-style search params and pagination
 - [ ] 4.3 Add API key support (240 rpm with key vs 1k/day without)
 - [ ] 4.4 Implement DailyMed SPL adapter (by setid/NDC; parse LOINC-coded sections)
 - [ ] 4.5 Implement RxNav/RxNorm adapter (rxcui, ndcproperties endpoints)

 ## 5. Clinical Terminologies
diff --git a/pyproject.toml b/pyproject.toml
index 07a63820fbbd779d660bd541c152d2cab1f021dd..5d655fed093dca1ebe69e05fc94494ca8cf36c00 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -1,104 +1,94 @@
 [project]
 name = "Medical_KG"
 version = "0.1.0"
 description = "Production-ready Medical Knowledge Graph with GPU-accelerated processing"
 readme = "README.md"
 requires-python = ">=3.12"
 dependencies = [
     # HTTP & Async
     "httpx[http2]>=0.27.0",
     "tenacity>=8.2.0",
     "aiolimiter>=1.1.0",
     "anyio>=4.3.0",

-    # CLI & UI
-    "typer>=0.12.3",
-    "rich>=13.7.1",
-    "tqdm>=4.66.4",
-
     # Data Models & Validation
-    "pydantic>=2.7.1",
-    "pydantic-settings>=2.2.1",
     "python-dotenv>=1.0.1",
-    "jsonschema>=4.21.0",

     # JSON & Serialization
     "orjson>=3.10.4",
     "jsonlines>=4.0.0",
     "pyyaml>=6.0.1",

     # XML/HTML Parsing
     "lxml>=5.2.2",
     "beautifulsoup4>=4.12.3",
     "html5lib>=1.1",
     "xmltodict>=0.13.0",

     # RDF & SPARQL
     "rdflib>=7.0.0",
     "SPARQLWrapper>=2.0.0",

     # Authentication & Security
-    "authlib>=1.3.1",
     "cryptography>=42.0.0",

     # Date & Time
     "python-dateutil>=2.9.0.post0",

     # NLP & Text Processing
     "langdetect>=1.0.9",
     "rapidfuzz>=3.6.1",
     "spacy>=3.7.0",
     "scispacy>=0.5.4",
     "nltk>=3.8.1",
     "chardet>=5.2.0",
     "ftfy>=6.2.0",
     "unidecode>=1.3.8",

     # Machine Learning & Embeddings
     "torch>=2.2.0",
     "transformers>=4.38.0",
     "sentence-transformers>=2.5.0",
     "scikit-learn>=1.4.0",
     "numpy>=1.26.0",
     "scipy>=1.12.0",

     # Data Science
     "pandas>=2.2.2",
     "pyarrow>=15.0.0",

     # Databases & Storage
     "neo4j>=5.15.0",
     "opensearch-py>=2.4.0",
     "boto3>=1.34.0",
     "redis>=5.0.0",

     # APIs
     "fastapi>=0.110.0",
     "uvicorn[standard]>=0.27.0",
     "python-multipart>=0.0.9",
-    "pydantic[email]>=2.7.1",

     # SHACL & Validation
     "pyshacl>=0.25.0",

     # Orchestration
     "prefect>=2.16.0",

     # Monitoring & Observability
     "prometheus-client>=0.20.0",
     "opentelemetry-api>=1.23.0",
     "opentelemetry-sdk>=1.23.0",
     "opentelemetry-instrumentation-fastapi>=0.44b0",
     "opentelemetry-instrumentation-httpx>=0.44b0",

     # Caching
     "cachetools>=5.3.0",

     # PDF Processing (GPU-only)
     "mineru[all]>=0.1.0",

     # LLM Serving (GPU-only)
     "vllm>=0.3.0",
 ]

 [project.optional-dependencies]
@@ -118,36 +108,39 @@ dev = [
     "pre-commit>=3.6.0",

     # Type Stubs
     "types-requests>=2.31.0",
     "types-pyyaml>=6.0.12",
     "types-redis>=4.6.0",
     "types-boto3>=1.34.0",

     # Documentation
     "mkdocs>=1.5.3",
     "mkdocs-material>=9.5.0",

     # Debugging & Profiling
     "ipython>=8.21.0",
     "ipdb>=0.13.13",
     "memory-profiler>=0.61.0",
     "py-spy>=0.3.14",
 ]

 models = [
     # SpaCy Models (download separately)
     # python -m spacy download en_core_sci_md
     # python -m spacy download en_core_web_sm
 ]

+[project.scripts]
+med = "Medical_KG.cli:main"
+
 [tool.black]
 line-length = 100

 [tool.ruff]
 line-length = 100
 target-version = "py312"
 extend-select = ["I"]

 [tool.mypy]
 python_version = "3.12"
 strict = true
diff --git a/src/Medical_KG/__init__.py b/src/Medical_KG/__init__.py
index a116ed9161cc1f563232ffc4e596adf4821438e8..430e35f9be0aebcef9377c46e21db3b4cf6fe3f2 100644
--- a/src/Medical_KG/__init__.py
+++ b/src/Medical_KG/__init__.py
@@ -1,2 +1,21 @@
+"""Medical_KG package exports."""
+
+from typing import TYPE_CHECKING, Any
+
+from Medical_KG.config.manager import ConfigManager, ConfigError
+
+if TYPE_CHECKING:  # pragma: no cover
+    from Medical_KG.app import create_app as _create_app
+
+
+def create_app(*args: Any, **kwargs: Any):
+    from Medical_KG.app import create_app as _factory
+
+    return _factory(*args, **kwargs)
+
+
 def ping() -> str:
     return "pong"
+
+
+__all__ = ["create_app", "ConfigManager", "ConfigError", "ping"]
diff --git a/src/Medical_KG/app.py b/src/Medical_KG/app.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f8e7e210cd96edcad229a763d81abe9bbe2f8b3
--- /dev/null
+++ b/src/Medical_KG/app.py
@@ -0,0 +1,37 @@
+"""FastAPI application exposing configuration hot-reload endpoint."""
+from __future__ import annotations
+
+from fastapi import Depends, FastAPI, HTTPException, status
+from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
+
+from Medical_KG.config.manager import ConfigError, ConfigManager
+
+_security = HTTPBearer(auto_error=False)
+
+
+def create_app(manager: ConfigManager | None = None) -> FastAPI:
+    manager = manager or ConfigManager()
+    app = FastAPI(title="Medical KG", version=manager.version.raw)
+
+    @app.post("/admin/reload", tags=["admin"], summary="Hot reload configuration")
+    async def reload_config(credentials: HTTPAuthorizationCredentials = Depends(_security)) -> dict:
+        if credentials is None:
+            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Missing bearer token")
+        token = credentials.credentials
+        try:
+            manager.validate_jwt(token)
+            manager.reload()
+        except ConfigError as exc:
+            message = str(exc)
+            lowered = message.lower()
+            if "token" in lowered or "scope" in lowered or "issuer" in lowered or "audience" in lowered:
+                status_code = status.HTTP_403_FORBIDDEN
+            else:
+                status_code = status.HTTP_400_BAD_REQUEST
+            raise HTTPException(status_code=status_code, detail=message) from exc
+        return {"config_version": manager.version.raw, "hash": manager.version.hash}
+
+    return app
+
+
+__all__ = ["create_app"]
diff --git a/src/Medical_KG/cli.py b/src/Medical_KG/cli.py
new file mode 100644
index 0000000000000000000000000000000000000000..ee364912ae381e84e66fd00c4ca204cab8e2ef59
--- /dev/null
+++ b/src/Medical_KG/cli.py
@@ -0,0 +1,91 @@
+"""Simple command-line interface for configuration management."""
+from __future__ import annotations
+
+import argparse
+import json
+import sys
+from pathlib import Path
+from typing import Optional
+
+from Medical_KG.config.manager import ConfigError, ConfigManager, ConfigValidator, mask_secrets
+
+
+def _load_manager(config_dir: Optional[Path]) -> ConfigManager:
+    base_path = config_dir or Path(__file__).resolve().parent / "config"
+    return ConfigManager(base_path=base_path)
+
+
+def _command_validate(args: argparse.Namespace) -> int:
+    try:
+        manager = _load_manager(args.config_dir)
+        payload = manager.raw_payload()
+        ConfigValidator(manager.base_path / "config.schema.json").validate(payload)
+        _ = manager.config
+    except ConfigError as exc:
+        print(f"Configuration invalid: {exc}")
+        return 1
+    message = "Config valid (strict)" if args.strict else "Config valid"
+    print(message)
+    return 0
+
+
+def _command_show(args: argparse.Namespace) -> int:
+    try:
+        manager = _load_manager(args.config_dir)
+        payload = manager.raw_payload()
+        if args.mask:
+            payload = mask_secrets(payload)
+    except ConfigError as exc:
+        print(f"Unable to load configuration: {exc}")
+        return 1
+    print(json.dumps(payload, indent=2, sort_keys=True))
+    return 0
+
+
+def _command_policy(args: argparse.Namespace) -> int:
+    try:
+        manager = _load_manager(args.config_dir)
+        policy = manager.policy
+    except ConfigError as exc:
+        print(f"Unable to load policy: {exc}")
+        return 1
+    for vocab, config in policy.vocabs.items():
+        territory = config.territory or "-"
+        licensed = "licensed" if config.licensed else "unlicensed"
+        print(f"{vocab}: {licensed} ({territory})")
+    return 0
+
+
+def build_parser() -> argparse.ArgumentParser:
+    parser = argparse.ArgumentParser(prog="med", description="Medical KG command-line tools")
+    subparsers = parser.add_subparsers(dest="command", required=True)
+
+    config_parser = subparsers.add_parser("config", help="Configuration commands")
+    config_subparsers = config_parser.add_subparsers(dest="config_command", required=True)
+
+    validate = config_subparsers.add_parser("validate", help="Validate configuration files")
+    validate.add_argument("--strict", action="store_true", help="Fail on any warning")
+    validate.add_argument("--config-dir", type=Path, default=None, help="Config directory")
+    validate.set_defaults(func=_command_validate)
+
+    show = config_subparsers.add_parser("show", help="Print effective configuration")
+    show.add_argument("--config-dir", type=Path, default=None, help="Config directory")
+    show.add_argument("--mask", action="store_true", default=True)
+    show.add_argument("--no-mask", dest="mask", action="store_false")
+    show.set_defaults(func=_command_show)
+
+    policy = config_subparsers.add_parser("policy", help="Display licensing policy")
+    policy.add_argument("--config-dir", type=Path, default=None, help="Config directory")
+    policy.set_defaults(func=_command_policy)
+
+    return parser
+
+
+def main(argv: Optional[list[str]] = None) -> int:
+    parser = build_parser()
+    args = parser.parse_args(argv)
+    return args.func(args)
+
+
+if __name__ == "__main__":
+    sys.exit(main())
diff --git a/src/Medical_KG/config/config-dev.yaml b/src/Medical_KG/config/config-dev.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..3e1ca7102cd8d117fdc11d29ebce8626f707964f
--- /dev/null
+++ b/src/Medical_KG/config/config-dev.yaml
@@ -0,0 +1,51 @@
+{
+  "feature_flags": {
+    "extraction_experimental_enabled": true
+  },
+  "observability": {
+    "logging": {
+      "level": "debug"
+    }
+  },
+  "sources": {
+    "pubmed": {
+      "rate_limit": {
+        "requests_per_minute": 120,
+        "burst": 30
+      }
+    },
+    "pmc": {
+      "rate_limit": {
+        "requests_per_minute": 90,
+        "burst": 20
+      }
+    },
+    "clinicaltrials": {
+      "base_url": "https://sandbox.api.clinicaltrials.gov/api/v2",
+      "api_key": "${CTGOV_SANDBOX_KEY}"
+    },
+    "dailymed": {
+      "api_key": "${OPEN_FDA_SANDBOX_KEY}"
+    }
+  },
+  "kg": {
+    "neo4j_uri": "bolt://localhost:7687"
+  },
+  "catalog": {
+    "vocabs": {
+      "snomed": {
+        "enabled": false
+      },
+      "meddra": {
+        "enabled": false
+      }
+    }
+  },
+  "apis": {
+    "cors": {
+      "allowed_origins": [
+        "http://localhost:3000"
+      ]
+    }
+  }
+}
diff --git a/src/Medical_KG/config/config-prod.yaml b/src/Medical_KG/config/config-prod.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..cdc169c33e373e8c83fe308631aa75d9320711cd
--- /dev/null
+++ b/src/Medical_KG/config/config-prod.yaml
@@ -0,0 +1,62 @@
+{
+  "observability": {
+    "logging": {
+      "level": "warn"
+    },
+    "metrics": {
+      "push_interval_seconds": 10
+    },
+    "tracing": {
+      "sample_rate": 0.05
+    }
+  },
+  "sources": {
+    "pubmed": {
+      "api_key": "${NCBI_PROD_KEY}"
+    },
+    "pmc": {
+      "api_key": "${PMC_PROD_KEY}"
+    },
+    "clinicaltrials": {
+      "api_key": "${CTGOV_PROD_KEY}"
+    },
+    "dailymed": {
+      "api_key": "${OPEN_FDA_PROD_KEY}"
+    }
+  },
+  "feature_flags": {
+    "extraction_experimental_enabled": false
+  },
+  "kg": {
+    "neo4j_uri": "neo4j+s://prod.neo4j.medical-kg.internal:7687",
+    "username": "${NEO4J_PROD_USER}",
+    "password": "${NEO4J_PROD_PASSWORD}"
+  },
+  "catalog": {
+    "vocabs": {
+      "snomed": {
+        "enabled": true
+      },
+      "meddra": {
+        "enabled": true
+      }
+    }
+  },
+  "apis": {
+    "rate_limits": {
+      "public": {
+        "requests_per_minute": 60,
+        "burst": 30
+      },
+      "partner": {
+        "requests_per_minute": 240,
+        "burst": 120
+      }
+    },
+    "cors": {
+      "allowed_origins": [
+        "https://app.medical-kg.com"
+      ]
+    }
+  }
+}
diff --git a/src/Medical_KG/config/config-staging.yaml b/src/Medical_KG/config/config-staging.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..212990a968967762fb9222f3802ce7db33838f29
--- /dev/null
+++ b/src/Medical_KG/config/config-staging.yaml
@@ -0,0 +1,41 @@
+{
+  "observability": {
+    "logging": {
+      "level": "info"
+    }
+  },
+  "sources": {
+    "pubmed": {
+      "api_key": "${NCBI_STAGING_KEY}"
+    },
+    "pmc": {
+      "api_key": "${PMC_STAGING_KEY}"
+    },
+    "clinicaltrials": {
+      "api_key": "${CTGOV_STAGING_KEY}"
+    },
+    "dailymed": {
+      "api_key": "${OPEN_FDA_STAGING_KEY}"
+    }
+  },
+  "feature_flags": {
+    "extraction_experimental_enabled": false
+  },
+  "kg": {
+    "neo4j_uri": "neo4j+s://staging.neo4j.medical-kg.internal:7687"
+  },
+  "catalog": {
+    "vocabs": {
+      "snomed": {
+        "enabled": true
+      }
+    }
+  },
+  "apis": {
+    "cors": {
+      "allowed_origins": [
+        "https://staging.medical-kg.com"
+      ]
+    }
+  }
+}
diff --git a/src/Medical_KG/config/config.schema.json b/src/Medical_KG/config/config.schema.json
index 048c92a0fc4c0a4642150d6c5df0d65f3e4b4708..a1f9d64344af347fee60c63d55b3547f14a180d7 100644
--- a/src/Medical_KG/config/config.schema.json
+++ b/src/Medical_KG/config/config.schema.json
@@ -1,1013 +1,541 @@
 {
-    "$schema": "https://json-schema.org/draft/2020-12/schema",
-    "$id": "https://api.org/medkg/config.schema.json",
-    "title": "Medical Knowledge Graph Configuration",
-    "description": "Schema for validating the master config.yaml file",
-    "type": "object",
-    "required": [
-        "env",
-        "service",
-        "http",
-        "auth",
-        "sources",
-        "chunking",
-        "embeddings",
-        "retrieval",
-        "extraction",
-        "kg",
-        "catalog",
-        "apis",
-        "observability",
-        "licensing",
-        "feature_flags",
-        "retention",
-        "orchestration",
-        "mineru"
-    ],
-    "properties": {
-        "env": {
-            "type": "string",
-            "enum": [
-                "dev",
-                "staging",
-                "prod"
-            ],
-            "description": "Deployment environment"
+  "$schema": "https://json-schema.org/draft/2020-12/schema",
+  "title": "Medical KG Configuration",
+  "type": "object",
+  "required": [
+    "config_version",
+    "feature_flags",
+    "sources",
+    "chunking",
+    "embeddings",
+    "retrieval",
+    "extraction",
+    "kg",
+    "catalog",
+    "apis",
+    "observability",
+    "licensing"
+  ],
+  "properties": {
+    "config_version": {
+      "type": "string",
+      "description": "Semantic identifier for the configuration payload"
+    },
+    "feature_flags": {
+      "$ref": "#/definitions/featureFlags"
+    },
+    "sources": {
+      "type": "object",
+      "description": "Upstream data sources and credentials",
+      "additionalProperties": {
+        "$ref": "#/definitions/sourceConfig"
+      },
+      "minProperties": 1
+    },
+    "chunking": {
+      "type": "object",
+      "properties": {
+        "profiles": {
+          "type": "object",
+          "additionalProperties": {
+            "$ref": "#/definitions/chunkingProfile"
+          },
+          "minProperties": 1
+        }
+      },
+      "required": ["profiles"],
+      "additionalProperties": false
+    },
+    "embeddings": {
+      "$ref": "#/definitions/embeddingsConfig"
+    },
+    "retrieval": {
+      "$ref": "#/definitions/retrievalConfig"
+    },
+    "extraction": {
+      "$ref": "#/definitions/extractionConfig"
+    },
+    "kg": {
+      "$ref": "#/definitions/kgConfig"
+    },
+    "catalog": {
+      "$ref": "#/definitions/catalogConfig"
+    },
+    "apis": {
+      "$ref": "#/definitions/apiConfig"
+    },
+    "observability": {
+      "$ref": "#/definitions/observabilityConfig"
+    },
+    "licensing": {
+      "$ref": "#/definitions/licensingConfig"
+    }
+  },
+  "additionalProperties": false,
+  "definitions": {
+    "rateLimitConfig": {
+      "type": "object",
+      "properties": {
+        "requests_per_minute": {
+          "type": "integer",
+          "minimum": 1,
+          "description": "Requests allowed per minute"
         },
-        "region": {
-            "type": "string",
-            "pattern": "^[a-z]+-[a-z]+-[0-9]+$",
-            "description": "AWS region identifier"
+        "burst": {
+          "type": "integer",
+          "minimum": 1,
+          "description": "Burst capacity"
+        }
+      },
+      "required": ["requests_per_minute", "burst"],
+      "additionalProperties": false
+    },
+    "retryConfig": {
+      "type": "object",
+      "properties": {
+        "max_attempts": {
+          "type": "integer",
+          "minimum": 1,
+          "description": "Maximum retry attempts"
         },
-        "service": {
-            "type": "object",
-            "required": [
-                "name",
-                "api_version"
-            ],
-            "properties": {
-                "name": {
-                    "type": "string",
-                    "description": "Service name"
-                },
-                "api_version": {
-                    "type": "string",
-                    "pattern": "^[0-9]+\\.[0-9]+\\.[0-9]+$",
-                    "description": "API version in semantic versioning format"
-                }
-            }
+        "backoff_seconds": {
+          "type": "number",
+          "exclusiveMinimum": 0,
+          "description": "Base exponential backoff in seconds"
+        }
+      },
+      "required": ["max_attempts", "backoff_seconds"],
+      "additionalProperties": false
+    },
+    "sourceConfig": {
+      "type": "object",
+      "properties": {
+        "base_url": {
+          "type": "string",
+          "format": "uri",
+          "description": "Base URL for the data source"
         },
-        "http": {
-            "type": "object",
-            "required": [
-                "port",
-                "rate_limit_per_minute"
-            ],
-            "properties": {
-                "port": {
-                    "type": "integer",
-                    "minimum": 1024,
-                    "maximum": 65535,
-                    "description": "HTTP server port"
-                },
-                "cors_origins": {
-                    "type": "array",
-                    "items": {
-                        "type": "string",
-                        "format": "uri"
-                    },
-                    "description": "Allowed CORS origins"
-                },
-                "rate_limit_per_minute": {
-                    "type": "integer",
-                    "minimum": 1,
-                    "maximum": 10000,
-                    "description": "Global rate limit per minute"
-                },
-                "max_body_mb": {
-                    "type": "integer",
-                    "minimum": 1,
-                    "maximum": 100,
-                    "description": "Maximum request body size in MB"
-                }
-            }
+        "api_key": {
+          "type": "string",
+          "description": "Secret placeholder for API key"
         },
-        "auth": {
-            "type": "object",
-            "required": [
-                "oauth2"
-            ],
-            "properties": {
-                "oauth2": {
-                    "type": "object",
-                    "required": [
-                        "token_url",
-                        "jwks_url",
-                        "audience"
-                    ],
-                    "properties": {
-                        "token_url": {
-                            "type": "string",
-                            "format": "uri",
-                            "description": "OAuth2 token endpoint"
-                        },
-                        "jwks_url": {
-                            "type": "string",
-                            "format": "uri",
-                            "description": "JWKS endpoint for token verification"
-                        },
-                        "audience": {
-                            "type": "string",
-                            "description": "Expected audience claim in JWT"
-                        }
-                    }
-                },
-                "api_keys": {
-                    "type": "object",
-                    "properties": {
-                        "enabled": {
-                            "type": "boolean",
-                            "description": "Whether API key authentication is enabled"
-                        }
-                    }
-                }
-            }
+        "rate_limit": {
+          "$ref": "#/definitions/rateLimitConfig"
         },
-        "sources": {
-            "type": "object",
-            "properties": {
-                "ncbi": {
-                    "type": "object",
-                    "properties": {
-                        "api_key": {
-                            "type": "string",
-                            "description": "NCBI E-utilities API key"
-                        },
-                        "rate_limit": {
-                            "type": "number",
-                            "minimum": 1,
-                            "maximum": 100,
-                            "description": "Requests per second"
-                        },
-                        "retry_config": {
-                            "$ref": "#/definitions/retry_config"
-                        }
-                    }
-                },
-                "openfda": {
-                    "type": "object",
-                    "properties": {
-                        "api_key": {
-                            "type": "string",
-                            "description": "openFDA API key"
-                        },
-                        "rate_limit": {
-                            "type": "integer",
-                            "minimum": 1,
-                            "maximum": 1000,
-                            "description": "Requests per minute"
-                        },
-                        "retry_config": {
-                            "$ref": "#/definitions/retry_config"
-                        }
-                    }
-                },
-                "dailymed": {
-                    "type": "object",
-                    "properties": {
-                        "rate_limit": {
-                            "type": "integer",
-                            "minimum": 1,
-                            "maximum": 1000,
-                            "description": "Requests per minute"
-                        },
-                        "retry_config": {
-                            "$ref": "#/definitions/retry_config"
-                        }
-                    }
-                },
-                "clinicaltrials": {
-                    "type": "object",
-                    "properties": {
-                        "rate_limit": {
-                            "type": "integer",
-                            "minimum": 1,
-                            "maximum": 1000,
-                            "description": "Requests per minute"
-                        },
-                        "retry_config": {
-                            "$ref": "#/definitions/retry_config"
-                        }
-                    }
-                },
-                "icd11": {
-                    "type": "object",
-                    "properties": {
-                        "client_id": {
-                            "type": "string",
-                            "description": "WHO ICD-11 OAuth2 client ID"
-                        },
-                        "client_secret": {
-                            "type": "string",
-                            "description": "WHO ICD-11 OAuth2 client secret"
-                        },
-                        "rate_limit": {
-                            "type": "integer",
-                            "minimum": 1,
-                            "maximum": 1000,
-                            "description": "Requests per minute"
-                        },
-                        "retry_config": {
-                            "$ref": "#/definitions/retry_config"
-                        }
-                    }
-                },
-                "nice": {
-                    "type": "object",
-                    "properties": {
-                        "api_key": {
-                            "type": "string",
-                            "description": "NICE API key"
-                        },
-                        "rate_limit": {
-                            "type": "integer",
-                            "minimum": 1,
-                            "maximum": 1000,
-                            "description": "Requests per minute"
-                        },
-                        "retry_config": {
-                            "$ref": "#/definitions/retry_config"
-                        }
-                    }
-                }
-            }
+        "retry": {
+          "$ref": "#/definitions/retryConfig"
+        }
+      },
+      "required": ["base_url", "rate_limit", "retry"],
+      "additionalProperties": false
+    },
+    "chunkingProfile": {
+      "type": "object",
+      "properties": {
+        "target_tokens": {
+          "type": "integer",
+          "minimum": 1,
+          "description": "Desired tokens per chunk"
         },
-        "chunking": {
-            "type": "object",
-            "required": [
-                "profiles"
-            ],
-            "properties": {
-                "profiles": {
-                    "type": "object",
-                    "properties": {
-                        "imrad": {
-                            "$ref": "#/definitions/chunking_profile"
-                        },
-                        "registry": {
-                            "$ref": "#/definitions/chunking_profile"
-                        },
-                        "spl": {
-                            "$ref": "#/definitions/chunking_profile"
-                        },
-                        "guideline": {
-                            "$ref": "#/definitions/chunking_profile"
-                        }
-                    }
-                },
-                "tables_atomic": {
-                    "type": "boolean",
-                    "description": "Whether tables are treated as atomic chunks"
-                },
-                "overlap_hard_boundary": {
-                    "type": "boolean",
-                    "description": "Whether to create overlap at hard boundaries"
-                }
-            }
+        "overlap": {
+          "type": "integer",
+          "minimum": 0,
+          "description": "Token overlap between chunks"
         },
-        "embeddings": {
-            "type": "object",
-            "required": [
-                "vllm",
-                "splade"
-            ],
-            "properties": {
-                "vllm": {
-                    "type": "object",
-                    "required": [
-                        "api_base",
-                        "model",
-                        "require_gpu"
-                    ],
-                    "properties": {
-                        "api_base": {
-                            "type": "string",
-                            "format": "uri",
-                            "description": "vLLM server API base URL"
-                        },
-                        "model": {
-                            "type": "string",
-                            "description": "Model identifier"
-                        },
-                        "batch_size": {
-                            "type": "integer",
-                            "minimum": 1,
-                            "maximum": 512,
-                            "description": "Batch size for embedding requests"
-                        },
-                        "require_gpu": {
-                            "type": "boolean",
-                            "description": "Whether GPU is required (fail if unavailable)"
-                        },
-                        "max_model_len": {
-                            "type": "integer",
-                            "minimum": 1000,
-                            "maximum": 100000,
-                            "description": "Maximum model context length"
-                        },
-                        "gpu_memory_utilization": {
-                            "type": "number",
-                            "minimum": 0.1,
-                            "maximum": 0.95,
-                            "description": "GPU memory utilization fraction"
-                        },
-                        "dtype": {
-                            "type": "string",
-                            "enum": [
-                                "float16",
-                                "bfloat16",
-                                "float32"
-                            ],
-                            "description": "Model data type"
-                        },
-                        "trust_remote_code": {
-                            "type": "boolean",
-                            "description": "Whether to trust remote code"
-                        }
-                    }
-                },
-                "splade": {
-                    "type": "object",
-                    "required": [
-                        "model",
-                        "require_gpu"
-                    ],
-                    "properties": {
-                        "model": {
-                            "type": "string",
-                            "description": "SPLADE model identifier"
-                        },
-                        "require_gpu": {
-                            "type": "boolean",
-                            "description": "Whether GPU is required"
-                        },
-                        "top_k": {
-                            "type": "integer",
-                            "minimum": 1,
-                            "maximum": 1000,
-                            "description": "Number of top terms to keep"
-                        },
-                        "min_weight": {
-                            "type": "number",
-                            "minimum": 0.0,
-                            "maximum": 1.0,
-                            "description": "Minimum weight threshold"
-                        }
-                    }
-                }
-            }
+        "tau_coh": {
+          "type": "number",
+          "minimum": 0,
+          "maximum": 1,
+          "description": "Semantic coherence threshold"
+        }
+      },
+      "required": ["target_tokens", "overlap", "tau_coh"],
+      "additionalProperties": false
+    },
+    "embeddingsConfig": {
+      "type": "object",
+      "properties": {
+        "vllm_api_base": {
+          "type": "string",
+          "description": "Base URL for vLLM endpoint"
         },
-        "retrieval": {
-            "type": "object",
-            "required": [
-                "fusion"
-            ],
-            "properties": {
-                "fusion": {
-                    "type": "object",
-                    "required": [
-                        "method",
-                        "weights"
-                    ],
-                    "properties": {
-                        "method": {
-                            "type": "string",
-                            "enum": [
-                                "weighted",
-                                "rrf"
-                            ],
-                            "description": "Fusion method"
-                        },
-                        "weights": {
-                            "type": "object",
-                            "properties": {
-                                "splade": {
-                                    "type": "number",
-                                    "minimum": 0.0,
-                                    "maximum": 1.0
-                                },
-                                "dense": {
-                                    "type": "number",
-                                    "minimum": 0.0,
-                                    "maximum": 1.0
-                                },
-                                "bm25": {
-                                    "type": "number",
-                                    "minimum": 0.0,
-                                    "maximum": 1.0
-                                }
-                            },
-                            "description": "Fusion weights for each retriever"
-                        },
-                        "rrf_k": {
-                            "type": "integer",
-                            "minimum": 1,
-                            "maximum": 1000,
-                            "description": "RRF k parameter"
-                        }
-                    }
-                },
-                "reranker": {
-                    "type": "object",
-                    "properties": {
-                        "enabled": {
-                            "type": "boolean",
-                            "description": "Whether reranking is enabled"
-                        },
-                        "model": {
-                            "type": "string",
-                            "description": "Reranker model identifier"
-                        },
-                        "top_n": {
-                            "type": "integer",
-                            "minimum": 1,
-                            "maximum": 500,
-                            "description": "Number of items to rerank"
-                        }
-                    }
-                },
-                "bm25": {
-                    "type": "object",
-                    "properties": {
-                        "boosts": {
-                            "type": "object",
-                            "properties": {
-                                "title_path": {
-                                    "type": "number",
-                                    "minimum": 0.0
-                                },
-                                "facet_json": {
-                                    "type": "number",
-                                    "minimum": 0.0
-                                },
-                                "table_lines": {
-                                    "type": "number",
-                                    "minimum": 0.0
-                                },
-                                "body": {
-                                    "type": "number",
-                                    "minimum": 0.0
-                                }
-                            }
-                        },
-                        "k1": {
-                            "type": "number",
-                            "minimum": 0.0,
-                            "maximum": 5.0,
-                            "description": "BM25 k1 parameter"
-                        },
-                        "b": {
-                            "type": "number",
-                            "minimum": 0.0,
-                            "maximum": 1.0,
-                            "description": "BM25 b parameter"
-                        }
-                    }
-                },
-                "neighbor_merge": {
-                    "type": "object",
-                    "properties": {
-                        "min_cosine": {
-                            "type": "number",
-                            "minimum": 0.0,
-                            "maximum": 1.0,
-                            "description": "Minimum cosine similarity for merging"
-                        },
-                        "max_tokens": {
-                            "type": "integer",
-                            "minimum": 100,
-                            "maximum": 10000,
-                            "description": "Maximum tokens in merged passage"
-                        },
-                        "window_chars": {
-                            "type": "integer",
-                            "minimum": 100,
-                            "maximum": 5000,
-                            "description": "Character window for finding neighbors"
-                        }
-                    }
-                }
-            }
+        "model": {
+          "type": "string",
+          "description": "Embedding model identifier"
         },
-        "extraction": {
-            "type": "object",
-            "required": [
-                "schemas",
-                "llm"
-            ],
-            "properties": {
-                "schemas": {
-                    "type": "array",
-                    "items": {
-                        "type": "string"
-                    },
-                    "description": "Enabled extraction schemas"
-                },
-                "llm": {
-                    "type": "object",
-                    "required": [
-                        "model",
-                        "temperature",
-                        "max_tokens"
-                    ],
-                    "properties": {
-                        "model": {
-                            "type": "string",
-                            "description": "LLM model identifier"
-                        },
-                        "temperature": {
-                            "type": "number",
-                            "minimum": 0.0,
-                            "maximum": 2.0,
-                            "description": "LLM temperature parameter"
-                        },
-                        "max_tokens": {
-                            "type": "integer",
-                            "minimum": 100,
-                            "maximum": 10000,
-                            "description": "Maximum tokens per LLM response"
-                        },
-                        "timeout_ms": {
-                            "type": "integer",
-                            "minimum": 1000,
-                            "maximum": 60000,
-                            "description": "LLM request timeout in milliseconds"
-                        }
-                    }
-                },
-                "confidence_threshold": {
-                    "type": "number",
-                    "minimum": 0.0,
-                    "maximum": 1.0,
-                    "description": "Minimum confidence threshold for accepting extractions"
-                }
-            }
+        "batch_size": {
+          "type": "integer",
+          "minimum": 1,
+          "description": "Batch size for embeddings"
         },
-        "kg": {
-            "type": "object",
-            "required": [
-                "neo4j"
-            ],
-            "properties": {
-                "neo4j": {
-                    "type": "object",
-                    "required": [
-                        "uri",
-                        "database"
-                    ],
-                    "properties": {
-                        "uri": {
-                            "type": "string",
-                            "format": "uri",
-                            "description": "Neo4j connection URI"
-                        },
-                        "username": {
-                            "type": "string",
-                            "description": "Neo4j username"
-                        },
-                        "password": {
-                            "type": "string",
-                            "description": "Neo4j password"
-                        },
-                        "database": {
-                            "type": "string",
-                            "description": "Neo4j database name"
-                        }
-                    }
-                },
-                "batch_size": {
-                    "type": "integer",
-                    "minimum": 1,
-                    "maximum": 10000,
-                    "description": "Batch size for KG writes"
-                },
-                "shacl_enabled": {
-                    "type": "boolean",
-                    "description": "Whether SHACL validation is enabled"
-                }
-            }
+        "splade_top_k": {
+          "type": "integer",
+          "minimum": 1,
+          "description": "Top-K sparse terms to keep"
         },
-        "catalog": {
-            "type": "object",
-            "required": [
-                "ontologies"
-            ],
-            "properties": {
-                "ontologies": {
-                    "type": "object",
-                    "properties": {
-                        "snomed_ct": {
-                            "$ref": "#/definitions/ontology_config"
-                        },
-                        "icd11": {
-                            "$ref": "#/definitions/ontology_config"
-                        },
-                        "loinc": {
-                            "$ref": "#/definitions/ontology_config"
-                        },
-                        "rxnorm": {
-                            "$ref": "#/definitions/ontology_config"
-                        },
-                        "mesh": {
-                            "$ref": "#/definitions/ontology_config"
-                        },
-                        "hpo": {
-                            "$ref": "#/definitions/ontology_config"
-                        },
-                        "mondo": {
-                            "$ref": "#/definitions/ontology_config"
-                        }
-                    }
-                }
-            }
+        "require_gpu": {
+          "type": "boolean",
+          "description": "Whether GPU is required"
+        }
+      },
+      "required": [
+        "vllm_api_base",
+        "model",
+        "batch_size",
+        "splade_top_k",
+        "require_gpu"
+      ],
+      "additionalProperties": false
+    },
+    "fusionWeights": {
+      "type": "object",
+      "properties": {
+        "bm25": {
+          "type": "number",
+          "minimum": 0,
+          "maximum": 1,
+          "description": "BM25 weight"
         },
-        "apis": {
-            "type": "object",
-            "required": [
-                "rate_limits"
-            ],
-            "properties": {
-                "rate_limits": {
-                    "type": "object",
-                    "properties": {
-                        "retrieve": {
-                            "type": "integer",
-                            "minimum": 1,
-                            "maximum": 10000
-                        },
-                        "ingest": {
-                            "type": "integer",
-                            "minimum": 1,
-                            "maximum": 1000
-                        },
-                        "extract": {
-                            "type": "integer",
-                            "minimum": 1,
-                            "maximum": 5000
-                        },
-                        "admin": {
-                            "type": "integer",
-                            "minimum": 1,
-                            "maximum": 100
-                        }
-                    }
-                },
-                "cors": {
-                    "type": "object",
-                    "properties": {
-                        "allow_credentials": {
-                            "type": "boolean"
-                        },
-                        "max_age": {
-                            "type": "integer",
-                            "minimum": 0,
-                            "maximum": 86400
-                        }
-                    }
-                }
-            }
+        "splade": {
+          "type": "number",
+          "minimum": 0,
+          "maximum": 1,
+          "description": "SPLADE weight"
         },
-        "observability": {
-            "type": "object",
-            "required": [
-                "log_level"
-            ],
-            "properties": {
-                "log_level": {
-                    "type": "string",
-                    "enum": [
-                        "DEBUG",
-                        "INFO",
-                        "WARN",
-                        "ERROR"
-                    ],
-                    "description": "Logging level"
-                },
-                "metrics": {
-                    "type": "object",
-                    "properties": {
-                        "push_interval_sec": {
-                            "type": "integer",
-                            "minimum": 1,
-                            "maximum": 300,
-                            "description": "Metrics push interval in seconds"
-                        },
-                        "sinks": {
-                            "type": "array",
-                            "items": {
-                                "type": "string",
-                                "enum": [
-                                    "prometheus",
-                                    "elasticsearch"
-                                ]
-                            },
-                            "description": "Metrics export destinations"
-                        }
-                    }
-                },
-                "tracing": {
-                    "type": "object",
-                    "properties": {
-                        "sample_rate": {
-                            "type": "number",
-                            "minimum": 0.0,
-                            "maximum": 1.0,
-                            "description": "Tracing sample rate"
-                        }
-                    }
-                }
-            }
+        "dense": {
+          "type": "number",
+          "minimum": 0,
+          "maximum": 1,
+          "description": "Dense retriever weight"
+        }
+      },
+      "required": ["bm25", "splade", "dense"],
+      "additionalProperties": false,
+      "allOf": [
+        {
+          "description": "Fusion weights must sum to 1.0",
+          "properties": {
+            "bm25": {},
+            "splade": {},
+            "dense": {}
+          },
+          "unevaluatedProperties": false
+        }
+      ]
+    },
+    "fusionConfig": {
+      "type": "object",
+      "properties": {
+        "weights": {
+          "$ref": "#/definitions/fusionWeights"
         },
-        "licensing": {
-            "type": "object",
-            "required": [
-                "policy_file",
-                "default_tier"
-            ],
-            "properties": {
-                "policy_file": {
-                    "type": "string",
-                    "description": "Path to licensing policy file"
-                },
-                "default_tier": {
-                    "type": "string",
-                    "enum": [
-                        "internal",
-                        "member",
-                        "affiliate",
-                        "public"
-                    ],
-                    "description": "Default license tier"
-                },
-                "vocabularies": {
-                    "type": "object",
-                    "properties": {
-                        "snomed_ct": {
-                            "$ref": "#/definitions/vocabulary_license"
-                        },
-                        "umls": {
-                            "$ref": "#/definitions/vocabulary_license"
-                        },
-                        "meddra": {
-                            "$ref": "#/definitions/vocabulary_license"
-                        },
-                        "loinc": {
-                            "$ref": "#/definitions/vocabulary_license"
-                        },
-                        "rxnorm": {
-                            "$ref": "#/definitions/vocabulary_license"
-                        },
-                        "hpo": {
-                            "$ref": "#/definitions/vocabulary_license"
-                        }
-                    }
-                }
-            }
+        "rrf_k": {
+          "type": "integer",
+          "minimum": 1,
+          "description": "RRF k parameter"
+        }
+      },
+      "required": ["weights", "rrf_k"],
+      "additionalProperties": false
+    },
+    "rerankerConfig": {
+      "type": "object",
+      "properties": {
+        "enabled": {
+          "type": "boolean"
         },
-        "feature_flags": {
-            "type": "object",
-            "properties": {
-                "splade_enabled": {
-                    "type": "boolean",
-                    "description": "Whether SPLADE retrieval is enabled"
-                },
-                "reranker_enabled": {
-                    "type": "boolean",
-                    "description": "Whether reranking is enabled"
-                },
-                "extraction_experimental_enabled": {
-                    "type": "boolean",
-                    "description": "Whether experimental extractors are enabled"
-                },
-                "license_masking_enabled": {
-                    "type": "boolean",
-                    "description": "Whether license-based content masking is enabled"
-                },
-                "neighbor_merge_enabled": {
-                    "type": "boolean",
-                    "description": "Whether neighbor merging is enabled"
-                },
-                "multi_granularity_enabled": {
-                    "type": "boolean",
-                    "description": "Whether multi-granularity retrieval is enabled"
-                }
-            }
+        "top_n": {
+          "type": "integer",
+          "minimum": 1
+        }
+      },
+      "required": ["enabled", "top_n"],
+      "additionalProperties": false
+    },
+    "neighborMergeConfig": {
+      "type": "object",
+      "properties": {
+        "min_cosine": {
+          "type": "number",
+          "minimum": 0,
+          "maximum": 1
         },
-        "retention": {
-            "type": "object",
-            "properties": {
-                "object_store_days": {
-                    "type": "integer",
-                    "minimum": 1,
-                    "maximum": 3650,
-                    "description": "Object store retention in days"
-                },
-                "logs_days": {
-                    "type": "integer",
-                    "minimum": 1,
-                    "maximum": 365,
-                    "description": "Log retention in days"
-                },
-                "metrics_days": {
-                    "type": "integer",
-                    "minimum": 1,
-                    "maximum": 90,
-                    "description": "Metrics retention in days"
-                }
-            }
+        "max_tokens": {
+          "type": "integer",
+          "minimum": 1
+        }
+      },
+      "required": ["min_cosine", "max_tokens"],
+      "additionalProperties": false
+    },
+    "retrievalConfig": {
+      "type": "object",
+      "properties": {
+        "fusion": {
+          "$ref": "#/definitions/fusionConfig"
         },
-        "orchestration": {
-            "type": "object",
-            "required": [
-                "queue",
-                "topics"
-            ],
-            "properties": {
-                "queue": {
-                    "type": "object",
-                    "required": [
-                        "driver",
-                        "brokers"
-                    ],
-                    "properties": {
-                        "driver": {
-                            "type": "string",
-                            "enum": [
-                                "kafka",
-                                "redis"
-                            ],
-                            "description": "Queue driver"
-                        },
-                        "brokers": {
-                            "type": "array",
-                            "items": {
-                                "type": "string"
-                            },
-                            "description": "Queue broker addresses"
-                        }
-                    }
-                },
-                "topics": {
-                    "type": "object",
-                    "properties": {
-                        "ingest_requests": {
-                            "type": "string",
-                            "description": "Topic for ingest requests"
-                        },
-                        "ingest_results": {
-                            "type": "string",
-                            "description": "Topic for ingest results"
-                        },
-                        "chunk_requests": {
-                            "type": "string",
-                            "description": "Topic for chunking requests"
-                        },
-                        "embed_requests": {
-                            "type": "string",
-                            "description": "Topic for embedding requests"
-                        },
-                        "embed_results": {
-                            "type": "string",
-                            "description": "Topic for embedding results"
-                        },
-                        "mapping_events": {
-                            "type": "string",
-                            "description": "Topic for mapping events"
-                        }
-                    }
-                }
-            }
+        "reranker": {
+          "$ref": "#/definitions/rerankerConfig"
         },
-        "mineru": {
-            "type": "object",
-            "required": [
-                "endpoint",
-                "require_gpu"
-            ],
-            "properties": {
-                "endpoint": {
-                    "type": "string",
-                    "format": "uri",
-                    "description": "MinerU service endpoint"
-                },
-                "ocr_langs": {
-                    "type": "array",
-                    "items": {
-                        "type": "string"
-                    },
-                    "description": "Supported OCR languages"
-                },
-                "timeout_ms": {
-                    "type": "integer",
-                    "minimum": 1000,
-                    "maximum": 300000,
-                    "description": "MinerU request timeout"
-                },
-                "require_gpu": {
-                    "type": "boolean",
-                    "description": "Whether GPU is required for MinerU"
-                }
-            }
+        "neighbor_merge": {
+          "$ref": "#/definitions/neighborMergeConfig"
         }
+      },
+      "required": ["fusion", "reranker", "neighbor_merge"],
+      "additionalProperties": false
     },
-    "definitions": {
-        "retry_config": {
-            "type": "object",
-            "properties": {
-                "max_retries": {
-                    "type": "integer",
-                    "minimum": 0,
-                    "maximum": 10
-                },
-                "backoff_factor": {
-                    "type": "number",
-                    "minimum": 1.0,
-                    "maximum": 5.0
-                },
-                "jitter": {
-                    "type": "boolean"
-                }
-            }
+    "extractorConfig": {
+      "type": "object",
+      "properties": {
+        "intent": {
+          "type": "string",
+          "description": "Intent label",
+          "enum": [
+            "pico",
+            "endpoint",
+            "ae",
+            "dose",
+            "eligibility",
+            "general"
+          ]
         },
-        "chunking_profile": {
-            "type": "object",
-            "required": [
-                "target_tokens",
-                "overlap",
-                "tau_coh"
-            ],
-            "properties": {
-                "target_tokens": {
-                    "type": "integer",
-                    "minimum": 100,
-                    "maximum": 1200,
-                    "description": "Target tokens per chunk"
-                },
-                "overlap": {
-                    "type": "number",
-                    "minimum": 0.0,
-                    "maximum": 0.5,
-                    "description": "Overlap fraction between chunks"
-                },
-                "tau_coh": {
-                    "type": "number",
-                    "minimum": 0.0,
-                    "maximum": 1.0,
-                    "description": "Coherence threshold for chunk boundaries"
-                }
-            }
+        "prompt": {
+          "type": "string",
+          "description": "Prompt for extractor"
         },
-        "ontology_config": {
-            "type": "object",
-            "required": [
-                "enabled",
-                "license_required"
-            ],
-            "properties": {
-                "enabled": {
-                    "type": "boolean",
-                    "description": "Whether ontology is enabled"
-                },
-                "license_required": {
-                    "type": "boolean",
-                    "description": "Whether license is required"
-                },
-                "territory": {
-                    "type": "string",
-                    "description": "Geographic territory for licensing"
-                },
-                "update_schedule": {
-                    "type": "string",
-                    "description": "Cron schedule for updates"
-                }
-            }
+        "temperature": {
+          "type": "number",
+          "minimum": 0,
+          "maximum": 2
+        },
+        "max_tokens": {
+          "type": "integer",
+          "minimum": 1
+        },
+        "confidence_threshold": {
+          "type": "number",
+          "minimum": 0,
+          "maximum": 1
+        }
+      },
+      "required": [
+        "intent",
+        "prompt",
+        "temperature",
+        "max_tokens",
+        "confidence_threshold"
+      ],
+      "additionalProperties": false
+    },
+    "extractionConfig": {
+      "type": "object",
+      "properties": {
+        "pico": { "$ref": "#/definitions/extractorConfig" },
+        "effects": { "$ref": "#/definitions/extractorConfig" },
+        "adverse_events": { "$ref": "#/definitions/extractorConfig" },
+        "dosing": { "$ref": "#/definitions/extractorConfig" },
+        "eligibility": { "$ref": "#/definitions/extractorConfig" }
+      },
+      "required": [
+        "pico",
+        "effects",
+        "adverse_events",
+        "dosing",
+        "eligibility"
+      ],
+      "additionalProperties": false
+    },
+    "kgConfig": {
+      "type": "object",
+      "properties": {
+        "neo4j_uri": {
+          "type": "string",
+          "description": "Neo4j URI"
+        },
+        "username": {
+          "type": "string"
+        },
+        "password": {
+          "type": "string"
+        },
+        "batch_size": {
+          "type": "integer",
+          "minimum": 1
+        },
+        "shacl_enabled": {
+          "type": "boolean"
+        }
+      },
+      "required": [
+        "neo4j_uri",
+        "username",
+        "password",
+        "batch_size",
+        "shacl_enabled"
+      ],
+      "additionalProperties": false
+    },
+    "catalogVocabularyConfig": {
+      "type": "object",
+      "properties": {
+        "enabled": { "type": "boolean" },
+        "requires_license": { "type": "boolean" },
+        "refresh_cron": { "type": "string" },
+        "territory": { "type": ["string", "null"] }
+      },
+      "required": ["enabled", "requires_license", "refresh_cron"],
+      "additionalProperties": false
+    },
+    "catalogConfig": {
+      "type": "object",
+      "properties": {
+        "vocabs": {
+          "type": "object",
+          "minProperties": 1,
+          "additionalProperties": {
+            "$ref": "#/definitions/catalogVocabularyConfig"
+          }
+        },
+        "license_policy": {
+          "type": "string",
+          "description": "Relative path to policy.yaml"
+        }
+      },
+      "required": ["vocabs", "license_policy"],
+      "additionalProperties": false
+    },
+    "apiRateLimit": {
+      "type": "object",
+      "properties": {
+        "requests_per_minute": {
+          "type": "integer",
+          "minimum": 1
+        },
+        "burst": {
+          "type": "integer",
+          "minimum": 1
+        }
+      },
+      "required": ["requests_per_minute", "burst"],
+      "additionalProperties": false
+    },
+    "apiAuthConfig": {
+      "type": "object",
+      "properties": {
+        "issuer": { "type": "string" },
+        "audience": { "type": "string" },
+        "admin_scope": { "type": "string" },
+        "jwt_secret": { "type": "string" },
+        "token_ttl_seconds": {
+          "type": "integer",
+          "minimum": 60
+        }
+      },
+      "required": [
+        "issuer",
+        "audience",
+        "admin_scope",
+        "jwt_secret",
+        "token_ttl_seconds"
+      ],
+      "additionalProperties": false
+    },
+    "apiConfig": {
+      "type": "object",
+      "properties": {
+        "rate_limits": {
+          "type": "object",
+          "additionalProperties": {
+            "$ref": "#/definitions/apiRateLimit"
+          }
         },
-        "vocabulary_license": {
-            "type": "object",
-            "required": [
-                "licensed"
-            ],
-            "properties": {
-                "licensed": {
-                    "type": "boolean",
-                    "description": "Whether vocabulary is licensed"
-                },
-                "territory": {
-                    "type": "string",
-                    "description": "Geographic territory for license"
-                }
+        "auth": { "$ref": "#/definitions/apiAuthConfig" },
+        "cors": {
+          "type": "object",
+          "properties": {
+            "allowed_origins": {
+              "type": "array",
+              "items": { "type": "string" },
+              "description": "Allowed CORS origins"
             }
+          },
+          "required": ["allowed_origins"],
+          "additionalProperties": false
+        }
+      },
+      "required": ["rate_limits", "auth", "cors"],
+      "additionalProperties": false
+    },
+    "loggingConfig": {
+      "type": "object",
+      "properties": {
+        "level": {
+          "type": "string",
+          "enum": ["debug", "info", "warn", "error"],
+          "description": "Log level"
+        }
+      },
+      "required": ["level"],
+      "additionalProperties": false
+    },
+    "metricsConfig": {
+      "type": "object",
+      "properties": {
+        "push_interval_seconds": {
+          "type": "integer",
+          "minimum": 1
+        }
+      },
+      "required": ["push_interval_seconds"],
+      "additionalProperties": false
+    },
+    "tracingConfig": {
+      "type": "object",
+      "properties": {
+        "endpoint": { "type": "string" },
+        "sample_rate": {
+          "type": "number",
+          "minimum": 0,
+          "maximum": 1
+        }
+      },
+      "required": ["endpoint", "sample_rate"],
+      "additionalProperties": false
+    },
+    "observabilityConfig": {
+      "type": "object",
+      "properties": {
+        "logging": { "$ref": "#/definitions/loggingConfig" },
+        "metrics": { "$ref": "#/definitions/metricsConfig" },
+        "tracing": { "$ref": "#/definitions/tracingConfig" }
+      },
+      "required": ["logging", "metrics", "tracing"],
+      "additionalProperties": false
+    },
+    "licensingConfig": {
+      "type": "object",
+      "properties": {
+        "policy_path": {
+          "type": "string",
+          "description": "Path to policy.yaml"
         }
+      },
+      "required": ["policy_path"],
+      "additionalProperties": false
     },
-    "additionalProperties": false
+    "featureFlags": {
+      "type": "object",
+      "properties": {
+        "splade_enabled": { "type": "boolean" },
+        "reranker_enabled": { "type": "boolean" },
+        "extraction_experimental_enabled": { "type": "boolean" }
+      },
+      "required": [
+        "splade_enabled",
+        "reranker_enabled",
+        "extraction_experimental_enabled"
+      ],
+      "additionalProperties": false
+    }
+  }
 }
diff --git a/src/Medical_KG/config/config.yaml b/src/Medical_KG/config/config.yaml
index 8b6155aca2d3427e013888d98775c84cfa30f4c9..d3a2e5b78570eb0eb45b6e902c72fb78b0008e8f 100644
--- a/src/Medical_KG/config/config.yaml
+++ b/src/Medical_KG/config/config.yaml
@@ -1,298 +1,227 @@
-# Medical Knowledge Graph - Master Configuration
-# Single source of truth for all runtime behavior
-# Environment: prod
-
-# Environment and service identification
-env: prod
-region: us-east-1
-service:
-  name: medkg
-  api_version: 1.0.0
-
-# HTTP server configuration
-http:
-  port: 8080
-  cors_origins: ["https://*.internal.org"]
-  rate_limit_per_minute: 1200
-  max_body_mb: 20
-
-# Authentication and authorization
-auth:
-  oauth2:
-    token_url: "https://auth.org/oauth2/token"
-    jwks_url: "https://auth.org/.well-known/jwks.json"
-    audience: "medkg"
-  api_keys:
-    enabled: true
-
-# Data sources configuration
-sources:
-  # PubMed/PMC
-  ncbi:
-    api_key: "${NCBI_EUTILS_API_KEY}"
-    rate_limit: 10  # requests per second
-    retry_config:
-      max_retries: 3
-      backoff_factor: 2.0
-      jitter: true
-
-  # openFDA
-  openfda:
-    api_key: "${OPENFDA_API_KEY}"
-    rate_limit: 240  # requests per minute
-    retry_config:
-      max_retries: 3
-      backoff_factor: 2.0
-      jitter: true
-
-  # DailyMed
-  dailymed:
-    rate_limit: 60  # requests per minute
-    retry_config:
-      max_retries: 3
-      backoff_factor: 2.0
-      jitter: true
-
-  # ClinicalTrials.gov
-  clinicaltrials:
-    rate_limit: 100  # requests per minute
-    retry_config:
-      max_retries: 3
-      backoff_factor: 2.0
-      jitter: true
-
-  # WHO ICD-11
-  icd11:
-    client_id: "${WHO_ICD11_CLIENT_ID}"
-    client_secret: "${WHO_ICD11_CLIENT_SECRET}"
-    rate_limit: 100  # requests per minute
-    retry_config:
-      max_retries: 3
-      backoff_factor: 2.0
-      jitter: true
-
-  # NICE Guidelines
-  nice:
-    api_key: "${NICE_API_KEY}"
-    rate_limit: 60  # requests per minute
-    retry_config:
-      max_retries: 3
-      backoff_factor: 2.0
-      jitter: true
-
-# Chunking profiles for different document types
-chunking:
-  profiles:
-    imrad:
-      target_tokens: 600
-      overlap: 0.15  # 15% overlap
-      tau_coh: 0.55  # coherence threshold
-    registry:
-      target_tokens: 400
-      overlap: 0.15
-      tau_coh: 0.55
-    spl:
-      target_tokens: 450
-      overlap: 0.15
-      tau_coh: 0.55
-    guideline:
-      target_tokens: 400
-      overlap: 0.15
-      tau_coh: 0.55
-
-  # Global chunking settings
-  tables_atomic: true  # Never split tables across chunks
-  overlap_hard_boundary: false  # Don't create overlap at section boundaries
-
-# GPU embeddings configuration
-embeddings:
-  vllm:
-    api_base: "${VLLM_API_BASE}"
-    model: "Qwen/Qwen3-Embedding-8B"
-    batch_size: 64
-    require_gpu: true  # Enforce GPU availability
-    max_model_len: 32768
-    gpu_memory_utilization: 0.92
-    dtype: "bfloat16"
-    trust_remote_code: true
-
-  splade:
-    model: "naver/splade-v3"
-    require_gpu: true  # Enforce GPU availability
-    top_k: 400
-    min_weight: 0.05
-
-# Retrieval configuration
-retrieval:
-  fusion:
-    method: "weighted"
-    weights:
-      splade: 0.50
-      dense: 0.35
-      bm25: 0.15
-
-  reranker:
-    enabled: true
-    model: "qwen3-rerank"
-    top_n: 100
-
-  bm25:
-    boosts:
-      title_path: 2.0
-      facet_json: 1.6
-      table_lines: 1.2
-      body: 1.0
-    k1: 0.9
-    b: 0.35
-
-  neighbor_merge:
-    min_cosine: 0.60
-    max_tokens: 3000
-    window_chars: 1200
-
-# Clinical extraction configuration
-extraction:
-  schemas:
-    - "pico"
-    - "effects"
-    - "ae"
-    - "dose"
-    - "eligibility"
-
-  llm:
-    model: "qwen2.5-72b-instruct"
-    temperature: 0.0
-    max_tokens: 1024
-    timeout_ms: 15000
-
-  confidence_threshold: 0.70
-
-# Knowledge graph configuration
-kg:
-  neo4j:
-    uri: "${NEO4J_URI}"
-    username: "${NEO4J_USER}"
-    password: "${NEO4J_PASSWORD}"
-    database: "neo4j"
-
-  batch_size: 1000  # Batch size for writes
-  shacl_enabled: true
-
-# Concept catalog configuration
-catalog:
-  ontologies:
-    snomed_ct:
-      enabled: true
-      license_required: true
-      territory: "US"
-      update_schedule: "0 4 1 JAN,APR,JUL,OCT *"  # Quarterly
-
-    icd11:
-      enabled: true
-      license_required: false
-      update_schedule: "0 5 1 MAR,SEP *"
-
-    loinc:
-      enabled: true
-      license_required: false
-      update_schedule: "0 1 1 JAN,JUL *"
-
-    rxnorm:
-      enabled: true
-      license_required: false
-      update_schedule: "0 0 * * MON"  # Weekly
-
-    mesh:
-      enabled: true
-      license_required: false
-      update_schedule: "0 2 1 * *"
-
-    hpo:
-      enabled: true
-      license_required: false
-      update_schedule: "0 3 1 * *"
-
-    mondo:
-      enabled: true
-      license_required: false
-      update_schedule: "0 3 1 * *"
-
-# API configuration
-apis:
-  rate_limits:
-    retrieve: 1000  # requests per minute
-    ingest: 100     # requests per minute
-    extract: 500    # requests per minute
-    admin: 10       # requests per minute
-
-  cors:
-    allow_credentials: false
-    max_age: 86400
-
-# Observability configuration
-observability:
-  log_level: "INFO"
-  metrics:
-    push_interval_sec: 10
-    sinks: ["prometheus", "elasticsearch"]
-
-  tracing:
-    sample_rate: 0.1  # 10% in production
-
-# Licensing configuration
-licensing:
-  policy_file: "policy.yaml"
-  default_tier: "public"
-
-  # Vocabulary licensing status
-  vocabularies:
-    snomed_ct:
-      licensed: true
-      territory: "US"
-    umls:
-      licensed: true
-    meddra:
-      licensed: false
-    loinc:
-      licensed: true
-    rxnorm:
-      licensed: true
-    hpo:
-      licensed: true
-
-# Feature flags
-feature_flags:
-  splade_enabled: true
-  reranker_enabled: true
-  extraction_experimental_enabled: false
-  license_masking_enabled: true
-  neighbor_merge_enabled: true
-  multi_granularity_enabled: true
-
-# Data retention
-retention:
-  object_store_days: 365
-  logs_days: 30
-  metrics_days: 14
-
-# Orchestration
-orchestration:
-  queue:
-    driver: "kafka"
-    brokers: ["kafka-1:9092", "kafka-2:9092"]
-
-  topics:
-    ingest_requests: "ingest.requests.v1"
-    ingest_results: "ingest.results.v1"
-    chunk_requests: "chunk.requests.v1"
-    embed_requests: "embed.requests.v1"
-    embed_results: "embed.results.v1"
-    mapping_events: "mapping.events.v1"
-
-# MinerU PDF processing
-mineru:
-  endpoint: "http://mineru:9000"
-  ocr_langs: ["en", "es", "fr", "de"]
-  timeout_ms: 60000
-  require_gpu: true
-
+{
+  "config_version": "1.0.0",
+  "feature_flags": {
+    "splade_enabled": true,
+    "reranker_enabled": true,
+    "extraction_experimental_enabled": false
+  },
+  "sources": {
+    "pubmed": {
+      "base_url": "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/",
+      "api_key": "${NCBI_API_KEY}",
+      "rate_limit": {
+        "requests_per_minute": 600,
+        "burst": 120
+      },
+      "retry": {
+        "max_attempts": 5,
+        "backoff_seconds": 2.0
+      }
+    },
+    "pmc": {
+      "base_url": "https://www.ncbi.nlm.nih.gov/pmc/oai/oai.cgi",
+      "api_key": "${PMC_API_KEY}",
+      "rate_limit": {
+        "requests_per_minute": 300,
+        "burst": 60
+      },
+      "retry": {
+        "max_attempts": 5,
+        "backoff_seconds": 2.0
+      }
+    },
+    "clinicaltrials": {
+      "base_url": "https://clinicaltrials.gov/api/v2",
+      "api_key": "${CTGOV_API_KEY}",
+      "rate_limit": {
+        "requests_per_minute": 120,
+        "burst": 30
+      },
+      "retry": {
+        "max_attempts": 4,
+        "backoff_seconds": 3.0
+      }
+    },
+    "dailymed": {
+      "base_url": "https://api.fda.gov/drug/label.json",
+      "api_key": "${OPEN_FDA_API_KEY}",
+      "rate_limit": {
+        "requests_per_minute": 240,
+        "burst": 60
+      },
+      "retry": {
+        "max_attempts": 4,
+        "backoff_seconds": 2.5
+      }
+    }
+  },
+  "chunking": {
+    "profiles": {
+      "imrad": {
+        "target_tokens": 512,
+        "overlap": 64,
+        "tau_coh": 0.82
+      },
+      "registry": {
+        "target_tokens": 400,
+        "overlap": 48,
+        "tau_coh": 0.8
+      },
+      "spl": {
+        "target_tokens": 350,
+        "overlap": 32,
+        "tau_coh": 0.78
+      },
+      "guideline": {
+        "target_tokens": 420,
+        "overlap": 40,
+        "tau_coh": 0.81
+      }
+    }
+  },
+  "embeddings": {
+    "vllm_api_base": "${VLLM_API_BASE:https://localhost:9001}",
+    "model": "qwen2.5-7b-instruct",
+    "batch_size": 16,
+    "splade_top_k": 1000,
+    "require_gpu": true
+  },
+  "retrieval": {
+    "fusion": {
+      "weights": {
+        "bm25": 0.4,
+        "splade": 0.3,
+        "dense": 0.3
+      },
+      "rrf_k": 60
+    },
+    "reranker": {
+      "enabled": true,
+      "top_n": 50
+    },
+    "neighbor_merge": {
+      "min_cosine": 0.82,
+      "max_tokens": 1800
+    }
+  },
+  "extraction": {
+    "pico": {
+      "intent": "pico",
+      "prompt": "Extract study Population, Intervention, Comparator, Outcomes with rationale.",
+      "temperature": 0.0,
+      "max_tokens": 512,
+      "confidence_threshold": 0.35
+    },
+    "effects": {
+      "intent": "endpoint",
+      "prompt": "Summarize the primary and secondary efficacy endpoints with metrics.",
+      "temperature": 0.0,
+      "max_tokens": 512,
+      "confidence_threshold": 0.4
+    },
+    "adverse_events": {
+      "intent": "ae",
+      "prompt": "List clinically significant adverse events with frequency and severity.",
+      "temperature": 0.1,
+      "max_tokens": 512,
+      "confidence_threshold": 0.45
+    },
+    "dosing": {
+      "intent": "dose",
+      "prompt": "Extract recommended dosing regimens including titration guidance.",
+      "temperature": 0.0,
+      "max_tokens": 400,
+      "confidence_threshold": 0.3
+    },
+    "eligibility": {
+      "intent": "eligibility",
+      "prompt": "Capture key inclusion and exclusion criteria verbatim with rationale.",
+      "temperature": 0.0,
+      "max_tokens": 512,
+      "confidence_threshold": 0.35
+    }
+  },
+  "kg": {
+    "neo4j_uri": "${NEO4J_URI:neo4j://localhost:7687}",
+    "username": "${NEO4J_USERNAME:neo4j}",
+    "password": "${NEO4J_PASSWORD}",
+    "batch_size": 500,
+    "shacl_enabled": true
+  },
+  "catalog": {
+    "vocabs": {
+      "snomed": {
+        "enabled": false,
+        "requires_license": true,
+        "refresh_cron": "0 2 * * *",
+        "territory": "US"
+      },
+      "meddra": {
+        "enabled": true,
+        "requires_license": true,
+        "refresh_cron": "0 3 * * 1",
+        "territory": "US"
+      },
+      "loinc": {
+        "enabled": true,
+        "requires_license": true,
+        "refresh_cron": "0 4 * * 3"
+      },
+      "rxnorm": {
+        "enabled": true,
+        "requires_license": false,
+        "refresh_cron": "0 5 * * *"
+      },
+      "hpo": {
+        "enabled": true,
+        "requires_license": false,
+        "refresh_cron": "0 6 * * 0"
+      }
+    },
+    "license_policy": "policy.yaml"
+  },
+  "apis": {
+    "rate_limits": {
+      "public": {
+        "requests_per_minute": 120,
+        "burst": 60
+      },
+      "partner": {
+        "requests_per_minute": 300,
+        "burst": 120
+      },
+      "admin": {
+        "requests_per_minute": 600,
+        "burst": 240
+      }
+    },
+    "auth": {
+      "issuer": "https://medical-kg/auth",
+      "audience": "medical-kg-api",
+      "admin_scope": "admin:config",
+      "jwt_secret": "${API_JWT_SECRET}",
+      "token_ttl_seconds": 3600
+    },
+    "cors": {
+      "allowed_origins": [
+        "https://localhost:3000",
+        "https://medical-kg.dev"
+      ]
+    }
+  },
+  "observability": {
+    "logging": {
+      "level": "info"
+    },
+    "metrics": {
+      "push_interval_seconds": 15
+    },
+    "tracing": {
+      "endpoint": "http://localhost:4318",
+      "sample_rate": 0.1
+    }
+  },
+  "licensing": {
+    "policy_path": "policy.yaml"
+  }
+}
diff --git a/src/Medical_KG/config/manager.py b/src/Medical_KG/config/manager.py
new file mode 100644
index 0000000000000000000000000000000000000000..79ba4f5fc2dbf41c7ce4310d621b351c8e45a427
--- /dev/null
+++ b/src/Medical_KG/config/manager.py
@@ -0,0 +1,416 @@
+"""Configuration loading, validation, and hot-reload support."""
+from __future__ import annotations
+
+import base64
+import hashlib
+import hmac
+import json
+import os
+import re
+from dataclasses import dataclass
+from datetime import datetime, timezone
+from pathlib import Path
+from typing import Any, Dict, Mapping, MutableMapping, Optional
+
+import yaml
+
+from .models import Config, PolicyDocument, validate_constraints
+
+try:  # pragma: no cover - optional dependency
+    from prometheus_client import Gauge  # type: ignore
+except ModuleNotFoundError:  # pragma: no cover
+
+    class Gauge:  # type: ignore
+        def __init__(self, *_: Any, **__: Any) -> None:
+            pass
+
+        def labels(self, **_: Any) -> "Gauge":
+            return self
+
+        def set(self, *_: Any, **__: Any) -> None:
+            return None
+
+        def clear(self) -> None:
+            return None
+
+
+CONFIG_INFO = Gauge("config_info", "Current configuration metadata", ["version", "hash"])
+FEATURE_FLAG = Gauge("feature_flag", "Feature flag states", ["name"])
+
+ENV_SIMPLE_PATHS: Mapping[str, str] = {
+    "VLLM_API_BASE": "embeddings.vllm_api_base",
+    "RETRIEVAL_FUSION_WEIGHTS": "retrieval.fusion.weights",
+    "LOG_LEVEL": "observability.logging.level",
+}
+
+PLACEHOLDER_PATTERN = re.compile(r"\${([A-Z0-9_]+)(?::([^}]+))?}")
+
+
+class ConfigError(RuntimeError):
+    """Raised when configuration validation fails."""
+
+
+@dataclass
+class ConfigVersion:
+    raw: str
+    hash: str
+
+    @classmethod
+    def from_payload(cls, payload: Mapping[str, Any]) -> "ConfigVersion":
+        canonical = json.dumps(payload, sort_keys=True, separators=(",", ":"))
+        digest = hashlib.sha256(canonical.encode("utf-8")).hexdigest()
+        version = f"{datetime.now(timezone.utc).isoformat()}+{digest[:12]}"
+        return cls(raw=version, hash=digest)
+
+
+class SecretResolver:
+    """Resolves ${VAR} placeholders using environment variables or provided mapping."""
+
+    def __init__(self, env: Optional[Mapping[str, str]] = None):
+        self._env = dict(env or os.environ)
+
+    def resolve(self, key: str, default: Optional[str] = None) -> str:
+        if key in self._env:
+            return self._env[key]
+        if default is not None:
+            return default
+        raise ConfigError(f"Missing required secret: {key}")
+
+
+class ConfigValidator:
+    """Minimal JSON Schema validator supporting the subset used by config.schema.json."""
+
+    def __init__(self, schema_path: Path):
+        with schema_path.open("r", encoding="utf-8") as handle:
+            self._schema = json.load(handle)
+        self._definitions = self._schema.get("definitions", {})
+
+    def validate(self, payload: Mapping[str, Any]) -> None:
+        errors: list[str] = []
+        self._validate_schema(payload, self._schema, [], errors)
+        if errors:
+            raise ConfigError("; ".join(errors))
+
+    def _resolve(self, schema: Mapping[str, Any]) -> Mapping[str, Any]:
+        if "$ref" in schema:
+            ref = schema["$ref"]
+            if not ref.startswith("#/definitions/"):
+                raise ConfigError(f"Unsupported $ref: {ref}")
+            key = ref.split("/")[-1]
+            return self._definitions[key]
+        return schema
+
+    def _validate_schema(
+        self,
+        value: Any,
+        schema: Mapping[str, Any],
+        path: list[str],
+        errors: list[str],
+    ) -> None:
+        schema = self._resolve(schema)
+        schema_type = schema.get("type")
+        if isinstance(schema_type, list):
+            if value is None and "null" in schema_type:
+                return
+            schema_type = [t for t in schema_type if t != "null"]
+            schema_type = schema_type[0] if schema_type else None
+        if schema_type == "object":
+            if not isinstance(value, MutableMapping):
+                errors.append(self._format_path(path, "expected object"))
+                return
+            properties = schema.get("properties", {})
+            required = schema.get("required", [])
+            for key in required:
+                if key not in value:
+                    errors.append(self._format_path(path + [key], "missing required property"))
+            for key, val in value.items():
+                subschema = properties.get(key)
+                if subschema is not None:
+                    self._validate_schema(val, subschema, path + [key], errors)
+                elif not schema.get("additionalProperties", True):
+                    errors.append(self._format_path(path + [key], "unexpected property"))
+        elif schema_type == "array":
+            if not isinstance(value, list):
+                errors.append(self._format_path(path, "expected array"))
+                return
+            item_schema = schema.get("items")
+            for index, item in enumerate(value):
+                if item_schema is not None:
+                    self._validate_schema(item, item_schema, path + [str(index)], errors)
+        elif schema_type == "string":
+            if not isinstance(value, str):
+                errors.append(self._format_path(path, "expected string"))
+                return
+            enum = schema.get("enum")
+            if enum and value not in enum:
+                errors.append(self._format_path(path, f"must be one of {enum}"))
+        elif schema_type == "integer":
+            if not isinstance(value, int):
+                errors.append(self._format_path(path, "expected integer"))
+                return
+            self._validate_numeric_bounds(value, schema, path, errors)
+        elif schema_type == "number":
+            if not isinstance(value, (int, float)):
+                errors.append(self._format_path(path, "expected number"))
+                return
+            self._validate_numeric_bounds(float(value), schema, path, errors)
+        elif schema_type == "boolean":
+            if not isinstance(value, bool):
+                errors.append(self._format_path(path, "expected boolean"))
+        else:
+            # fallback: still walk subschemas if present
+            if isinstance(value, MutableMapping) and "properties" in schema:
+                self._validate_schema(value, {"type": "object", **schema}, path, errors)
+
+    def _validate_numeric_bounds(
+        self, value: float, schema: Mapping[str, Any], path: list[str], errors: list[str]
+    ) -> None:
+        minimum = schema.get("minimum")
+        if minimum is not None and value < minimum:
+            errors.append(self._format_path(path, f"must be >= {minimum}"))
+        maximum = schema.get("maximum")
+        if maximum is not None and value > maximum:
+            errors.append(self._format_path(path, f"must be <= {maximum}"))
+
+    def _format_path(self, path: list[str], message: str) -> str:
+        location = "/".join(path) if path else "<root>"
+        return f"{location}: {message}"
+
+
+class ConfigManager:
+    """Central coordinator for runtime configuration."""
+
+    def __init__(
+        self,
+        base_path: Optional[Path] = None,
+        env: Optional[str] = None,
+        secret_resolver: Optional[SecretResolver] = None,
+    ) -> None:
+        self.base_path = base_path or Path(__file__).resolve().parent
+        self.env = (env or os.getenv("CONFIG_ENV", "dev")).lower()
+        self.secret_resolver = secret_resolver or SecretResolver()
+        self.validator = ConfigValidator(self.base_path / "config.schema.json")
+        self.policy = self._load_policy()
+        self._config: Config
+        self._version: ConfigVersion
+        self.reload()
+
+    @property
+    def config(self) -> Config:
+        return self._config
+
+    @property
+    def version(self) -> ConfigVersion:
+        return self._version
+
+    def _load_policy(self) -> PolicyDocument:
+        policy_path = self.base_path / "policy.yaml"
+        with policy_path.open("r", encoding="utf-8") as handle:
+            policy_data = yaml.safe_load(handle) or {}
+        try:
+            return PolicyDocument.from_dict(policy_data)
+        except ValueError as exc:
+            raise ConfigError(f"policy.yaml invalid: {exc}") from exc
+
+    def reload(self) -> None:
+        payload = self._load_configuration_payload()
+        resolved = self._resolve_placeholders(payload)
+        self.validator.validate(resolved)
+        try:
+            validate_constraints(resolved)
+        except ValueError as exc:
+            raise ConfigError(str(exc)) from exc
+        config = Config(dict(resolved))
+        self._validate_licensing(config)
+        version = ConfigVersion.from_payload(resolved)
+        if hasattr(self, "_config"):
+            breaking = self._config.breaking_changes(config)
+            if breaking:
+                raise ConfigError(
+                    "Breaking change requires restart: " + ", ".join(sorted(breaking))
+                )
+        self._config = config
+        self._version = version
+        self._emit_metrics()
+
+    def raw_payload(self) -> Dict[str, Any]:
+        """Return the merged configuration payload prior to validation."""
+        return self._load_configuration_payload()
+
+    def _load_configuration_payload(self) -> Dict[str, Any]:
+        payload: Dict[str, Any] = self._load_yaml(self.base_path / "config.yaml")
+        env_specific = self.base_path / f"config-{self.env}.yaml"
+        if env_specific.exists():
+            payload = self._deep_merge(payload, self._load_yaml(env_specific))
+        override_path = self.base_path / "config-override.yaml"
+        if override_path.exists():
+            payload = self._deep_merge(payload, self._load_yaml(override_path))
+        payload = self._apply_env_overrides(payload)
+        return payload
+
+    def _load_yaml(self, path: Path) -> Dict[str, Any]:
+        with path.open("r", encoding="utf-8") as handle:
+            data = yaml.safe_load(handle) or {}
+        if not isinstance(data, MutableMapping):
+            raise ConfigError(f"{path.name} must contain a mapping at the root")
+        return dict(data)
+
+    def _deep_merge(self, base: Dict[str, Any], overlay: Mapping[str, Any]) -> Dict[str, Any]:
+        result: Dict[str, Any] = dict(base)
+        for key, value in overlay.items():
+            if (
+                key in result
+                and isinstance(result[key], MutableMapping)
+                and isinstance(value, Mapping)
+            ):
+                result[key] = self._deep_merge(result[key], value)  # type: ignore[arg-type]
+            else:
+                result[key] = value
+        return result
+
+    def _apply_env_overrides(self, payload: Dict[str, Any]) -> Dict[str, Any]:
+        result = dict(payload)
+        # handle explicit mappings
+        for env_name, dotted_path in ENV_SIMPLE_PATHS.items():
+            if env_name in os.environ:
+                self._set_dotted_key(result, dotted_path, self._parse_env_value(os.environ[env_name]))
+        # handle MEDCFG__ style overrides
+        for env_name, value in os.environ.items():
+            if not env_name.startswith("MEDCFG__"):
+                continue
+            dotted = env_name[len("MEDCFG__") :].lower().replace("__", ".")
+            self._set_dotted_key(result, dotted, self._parse_env_value(value))
+        return result
+
+    def _parse_env_value(self, raw: str) -> Any:
+        raw = raw.strip()
+        if raw.lower() in {"true", "false"}:
+            return raw.lower() == "true"
+        try:
+            return json.loads(raw)
+        except json.JSONDecodeError:
+            pass
+        try:
+            if "." in raw:
+                return float(raw)
+            return int(raw)
+        except ValueError:
+            return raw
+
+    def _set_dotted_key(self, payload: Dict[str, Any], dotted_path: str, value: Any) -> None:
+        parts = dotted_path.split(".")
+        cursor: Dict[str, Any] = payload
+        for part in parts[:-1]:
+            cursor = cursor.setdefault(part, {})  # type: ignore[assignment]
+        cursor[parts[-1]] = value
+
+    def _resolve_placeholders(self, payload: Mapping[str, Any]) -> Dict[str, Any]:
+        def _resolve(value: Any) -> Any:
+            if isinstance(value, str):
+                return self._resolve_string(value)
+            if isinstance(value, Mapping):
+                return {key: _resolve(val) for key, val in value.items()}
+            if isinstance(value, list):
+                return [_resolve(item) for item in value]
+            return value
+
+        return {key: _resolve(val) for key, val in payload.items()}
+
+    def _resolve_string(self, value: str) -> str:
+        def replace(match: re.Match[str]) -> str:
+            key = match.group(1)
+            default = match.group(2)
+            return self.secret_resolver.resolve(key, default)
+
+        return PLACEHOLDER_PATTERN.sub(replace, value)
+
+    def _validate_licensing(self, config: Config) -> None:
+        for vocab_name, vocab_config in config.catalog_vocabs().items():
+            policy_entry = self.policy.vocabs.get(vocab_name.upper())
+            requires_license = bool(vocab_config.get("requires_license"))
+            enabled = bool(vocab_config.get("enabled"))
+            if (
+                enabled
+                and requires_license
+                and (policy_entry is None or not policy_entry.get("licensed"))
+            ):
+                raise ConfigError(
+                    f"{vocab_name} requires affiliate license but policy.yaml marks it unlicensed"
+                )
+
+    def _emit_metrics(self) -> None:
+        CONFIG_INFO.clear()
+        CONFIG_INFO.labels(version=self._version.raw, hash=self._version.hash).set(1)
+        FEATURE_FLAG.clear()
+        for name, enabled in self._config.feature_flags().items():
+            FEATURE_FLAG.labels(name=name).set(1 if enabled else 0)
+
+    def validate_jwt(self, token: str) -> Mapping[str, Any]:
+        secret = self._config.auth_secret()
+        claims = self._decode_jwt(token, secret)
+        issuer = claims.get("iss")
+        audience = claims.get("aud")
+        expected = self._config.auth_settings()
+        if issuer != expected["issuer"]:
+            raise ConfigError("Invalid token issuer")
+        if audience != expected["audience"]:
+            raise ConfigError("Invalid token audience")
+        scope_field = claims.get("scope") or claims.get("scopes")
+        scopes: set[str]
+        if isinstance(scope_field, str):
+            scopes = set(scope_field.split())
+        elif isinstance(scope_field, list):
+            scopes = set(scope_field)
+        else:
+            scopes = set()
+        if expected["admin_scope"] not in scopes:
+            raise ConfigError("Admin scope missing from token")
+        return claims
+
+    def _decode_jwt(self, token: str, secret: str) -> Dict[str, Any]:
+        try:
+            header_b64, payload_b64, signature_b64 = token.split(".")
+        except ValueError as exc:  # pragma: no cover - defensive
+            raise ConfigError("Invalid admin token") from exc
+        signing_input = f"{header_b64}.{payload_b64}".encode("utf-8")
+        expected_signature = _b64url_encode(
+            hmac.new(secret.encode("utf-8"), signing_input, hashlib.sha256).digest()
+        )
+        if not hmac.compare_digest(expected_signature, signature_b64):
+            raise ConfigError("Invalid admin token")
+        header = json.loads(_b64url_decode(header_b64))
+        if header.get("alg") != "HS256":
+            raise ConfigError("Unsupported JWT algorithm")
+        payload = json.loads(_b64url_decode(payload_b64))
+        return payload
+
+
+def mask_secrets(data: Mapping[str, Any]) -> Dict[str, Any]:
+    """Return a deep copy of *data* with secret fields masked."""
+
+    def _mask(value: Any, key: Optional[str] = None) -> Any:
+        if isinstance(value, Mapping):
+            return {child_key: _mask(child_val, child_key) for child_key, child_val in value.items()}
+        if isinstance(value, list):
+            return [_mask(item, key) for item in value]
+        if isinstance(key, str) and any(
+            key.lower().endswith(suffix) for suffix in ("_key", "_secret", "_token", "password")
+        ):
+            return "***"
+        if isinstance(value, str) and PLACEHOLDER_PATTERN.search(value):
+            return "***"
+        return value
+
+    return {key: _mask(val, key) for key, val in data.items()}
+
+
+__all__ = ["ConfigManager", "ConfigError", "mask_secrets", "ConfigValidator", "SecretResolver"]
+
+
+def _b64url_decode(data: str) -> bytes:
+    padding = "=" * (-len(data) % 4)
+    return base64.urlsafe_b64decode((data + padding).encode("utf-8"))
+
+
+def _b64url_encode(data: bytes) -> str:
+    return base64.urlsafe_b64encode(data).decode("utf-8").rstrip("=")
diff --git a/src/Medical_KG/config/models.py b/src/Medical_KG/config/models.py
new file mode 100644
index 0000000000000000000000000000000000000000..b14b6981a5bdff1ae948f5c51e995ffc48b9d23a
--- /dev/null
+++ b/src/Medical_KG/config/models.py
@@ -0,0 +1,115 @@
+"""Lightweight configuration helpers and validation."""
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Any, Dict, List, Mapping
+
+
+def validate_constraints(payload: Mapping[str, Any]) -> None:
+    errors: List[str] = []
+    _check_positive_numbers(payload, errors)
+    _check_chunking(payload, errors)
+    _check_retrieval(payload, errors)
+    if errors:
+        raise ValueError("; ".join(errors))
+
+
+def _check_positive_numbers(payload: Mapping[str, Any], errors: List[str]) -> None:
+    def assert_positive(value: Any, path: str) -> None:
+        if not isinstance(value, (int, float)) or value <= 0:
+            errors.append(f"{path} must be positive")
+
+    for source_name, source in payload.get("sources", {}).items():
+        rate = source.get("rate_limit", {})
+        assert_positive(rate.get("requests_per_minute"), f"sources.{source_name}.rate_limit.requests_per_minute")
+        assert_positive(rate.get("burst"), f"sources.{source_name}.rate_limit.burst")
+        retry = source.get("retry", {})
+        assert_positive(retry.get("max_attempts"), f"sources.{source_name}.retry.max_attempts")
+        assert_positive(retry.get("backoff_seconds"), f"sources.{source_name}.retry.backoff_seconds")
+
+
+def _check_chunking(payload: Mapping[str, Any], errors: List[str]) -> None:
+    profiles = payload.get("chunking", {}).get("profiles", {})
+    for name, profile in profiles.items():
+        target = profile.get("target_tokens")
+        overlap = profile.get("overlap")
+        if isinstance(target, int) and isinstance(overlap, int) and overlap >= target:
+            errors.append(f"chunking.profiles.{name}.overlap must be less than target_tokens")
+
+
+def _check_retrieval(payload: Mapping[str, Any], errors: List[str]) -> None:
+    weights = payload.get("retrieval", {}).get("fusion", {}).get("weights", {})
+    if weights:
+        total = sum(weights.values())
+        if abs(total - 1.0) > 0.01:
+            errors.append("retrieval.fusion.weights must sum to 1.0±0.01")
+
+
+@dataclass
+class Config:
+    payload: Dict[str, Any]
+
+    def feature_flags(self) -> Dict[str, bool]:
+        return dict(self.payload.get("feature_flags", {}))
+
+    def effective_fusion_weights(self) -> Dict[str, float]:
+        weights = dict(self.payload["retrieval"]["fusion"]["weights"])
+        if not self.payload["feature_flags"].get("splade_enabled", True):
+            splade_weight = weights.pop("splade", 0.0)
+            remainder_keys = ["bm25", "dense"]
+            remainder_total = sum(weights.get(key, 0.0) for key in remainder_keys)
+            if remainder_total == 0:
+                for key in remainder_keys:
+                    weights[key] = 0.5
+            else:
+                for key in remainder_keys:
+                    weights[key] = weights.get(key, 0.0) + splade_weight * (
+                        weights.get(key, 0.0) / remainder_total
+                    )
+            weights["splade"] = 0.0
+        return weights
+
+    def breaking_changes(self, other: "Config") -> List[str]:
+        breaking: List[str] = []
+        if self.payload["embeddings"]["vllm_api_base"] != other.payload["embeddings"]["vllm_api_base"]:
+            breaking.append("embeddings.vllm_api_base")
+        if self.payload["kg"]["neo4j_uri"] != other.payload["kg"]["neo4j_uri"]:
+            breaking.append("kg.neo4j_uri")
+        return breaking
+
+    def non_breaking_diff(self, other: "Config") -> Dict[str, Dict[str, Any]]:
+        diff: Dict[str, Dict[str, Any]] = {}
+        if self.payload["observability"]["logging"]["level"] != other.payload["observability"]["logging"]["level"]:
+            diff.setdefault("observability.logging", {})["level"] = other.payload["observability"]["logging"]["level"]
+        if self.payload["retrieval"]["fusion"]["weights"] != other.payload["retrieval"]["fusion"]["weights"]:
+            diff.setdefault("retrieval.fusion", {})["weights"] = other.payload["retrieval"]["fusion"]["weights"]
+        if self.feature_flags() != other.feature_flags():
+            diff.setdefault("feature_flags", {})["values"] = other.feature_flags()
+        return diff
+
+    def auth_secret(self) -> str:
+        return str(self.payload["apis"]["auth"]["jwt_secret"])
+
+    def auth_settings(self) -> Mapping[str, Any]:
+        return self.payload["apis"]["auth"]
+
+    def catalog_vocabs(self) -> Mapping[str, Any]:
+        return self.payload["catalog"]["vocabs"]
+
+    def data(self) -> Dict[str, Any]:
+        return self.payload
+
+
+@dataclass
+class PolicyDocument:
+    vocabs: Mapping[str, Mapping[str, Any]]
+    actions: Mapping[str, Any]
+
+    @classmethod
+    def from_dict(cls, data: Mapping[str, Any]) -> "PolicyDocument":
+        if "vocabs" not in data or "actions" not in data:
+            raise ValueError("policy.yaml must define vocabs and actions")
+        return cls(vocabs=data["vocabs"], actions=data["actions"])
+
+
+__all__ = ["Config", "validate_constraints", "PolicyDocument"]
diff --git a/src/Medical_KG/config/policy.yaml b/src/Medical_KG/config/policy.yaml
index 583bc68d962f0102220806b3966103cfc1d2818c..05232ede56ca61ed4383c8f51dcc7f7aa87e3130 100644
--- a/src/Medical_KG/config/policy.yaml
+++ b/src/Medical_KG/config/policy.yaml
@@ -1,259 +1,26 @@
-# Medical Knowledge Graph - Licensing Policy
-# Defines licensing requirements and access controls for medical ontologies
-
-# Policy version and metadata
-version: "1.0"
-description: "Licensing policy for medical ontologies and data sources"
-last_updated: "2025-01-01"
-
-# Vocabulary licensing configuration
-vocabularies:
-  # SNOMED CT - requires affiliate license for non-member countries
-  snomed_ct:
-    name: "SNOMED CT"
-    license_required: true
-    license_type: "affiliate"
-    territories:
-      licensed: ["US", "UK", "CA", "AU", "NZ", "DE", "SE", "NO", "DK", "FI", "NL", "BE", "FR", "ES", "IT", "CH", "AT", "PT", "IE", "LU", "MT", "CY", "GR", "BG", "RO", "HR", "SI", "SK", "CZ", "PL", "HU", "LV", "LT", "EE", "IS", "LI"]
-      restricted: []  # No restrictions for licensed territories
-    access_control:
-      internal: "full"      # Full access for internal use
-      member: "full"        # Full access for member organizations
-      affiliate: "full"     # Full access for affiliate organizations
-      public: "restricted"  # Limited access for public use
-    restrictions:
-      public:
-        - "Redact concept labels and definitions"
-        - "Provide only concept IRIs and codes"
-        - "Include license attribution notice"
-    attribution_required: true
-    license_url: "https://www.snomed.org/snomed-ct/get-snomed-ct"
-
-  # UMLS - requires acceptance of UTS license
-  umls:
-    name: "Unified Medical Language System"
-    license_required: true
-    license_type: "acceptance"
-    access_control:
-      internal: "full"
-      member: "full"
-      affiliate: "full"
-      public: "restricted"
-    restrictions:
-      public:
-        - "Redact UMLS-specific content"
-        - "Provide only source vocabulary codes"
-        - "Include UTS license notice"
-    attribution_required: true
-    license_url: "https://uts.nlm.nih.gov/uts/"
-
-  # MedDRA - requires subscription license
-  meddra:
-    name: "Medical Dictionary for Regulatory Activities"
-    license_required: true
-    license_type: "subscription"
-    access_control:
-      internal: "full"
-      member: "full"
-      affiliate: "full"
-      public: "none"  # No public access
-    restrictions:
-      public:
-        - "Completely block access"
-        - "Return license required error"
-    attribution_required: true
-    license_url: "https://www.meddra.org/"
-
-  # LOINC - open with attribution
-  loinc:
-    name: "Logical Observation Identifiers Names and Codes"
-    license_required: false
-    license_type: "open"
-    access_control:
-      internal: "full"
-      member: "full"
-      affiliate: "full"
-      public: "full"
-    restrictions: {}
-    attribution_required: true
-    license_url: "https://loinc.org/license/"
-
-  # RxNorm - open with attribution
-  rxnorm:
-    name: "RxNorm"
-    license_required: false
-    license_type: "open"
-    access_control:
-      internal: "full"
-      member: "full"
-      affiliate: "full"
-      public: "full"
-    restrictions: {}
-    attribution_required: true
-    license_url: "https://www.nlm.nih.gov/research/umls/rxnorm/docs/rxnormfiles.html"
-
-  # HPO - open with attribution
-  hpo:
-    name: "Human Phenotype Ontology"
-    license_required: false
-    license_type: "open"
-    access_control:
-      internal: "full"
-      member: "full"
-      affiliate: "full"
-      public: "full"
-    restrictions: {}
-    attribution_required: true
-    license_url: "https://hpo.jax.org/app/license"
-
-  # MONDO - open with attribution
-  mondo:
-    name: "Mondo Disease Ontology"
-    license_required: false
-    license_type: "open"
-    access_control:
-      internal: "full"
-      member: "full"
-      affiliate: "full"
-      public: "full"
-    restrictions: {}
-    attribution_required: true
-    license_url: "https://mondo.monarchinitiative.org/"
-
-  # MeSH - open with attribution
-  mesh:
-    name: "Medical Subject Headings"
-    license_required: false
-    license_type: "open"
-    access_control:
-      internal: "full"
-      member: "full"
-      affiliate: "full"
-      public: "full"
-    restrictions: {}
-    attribution_required: true
-    license_url: "https://www.nlm.nih.gov/mesh/copyright_mesh.html"
-
-# Data source licensing
-data_sources:
-  # PMC Open Access - Creative Commons licenses
-  pmc:
-    license_required: false
-    license_type: "open"
-    attribution_required: true
-    license_url: "https://www.ncbi.nlm.nih.gov/pmc/tools/openftlist/"
-
-  # PubMed - public domain
-  pubmed:
-    license_required: false
-    license_type: "public_domain"
-    attribution_required: false
-
-  # ClinicalTrials.gov - public domain
-  clinicaltrials:
-    license_required: false
-    license_type: "public_domain"
-    attribution_required: false
-
-  # DailyMed - public domain
-  dailymed:
-    license_required: false
-    license_type: "public_domain"
-    attribution_required: false
-
-  # openFDA - public domain
-  openfda:
-    license_required: false
-    license_type: "public_domain"
-    attribution_required: false
-
-  # CDC data - public domain
-  cdc:
-    license_required: false
-    license_type: "public_domain"
-    attribution_required: false
-
-# Access control actions
-actions:
-  # Content filtering based on license tier
-  redact_unlicensed_codes:
-    enabled: true
-    description: "Redact labels and definitions for unlicensed vocabularies"
-
-  # KG write validation
-  block_kg_write_without_provenance:
-    enabled: true
-    description: "Block KG writes that lack proper provenance metadata"
-
-  # API response filtering
-  filter_api_responses_by_tier:
-    enabled: true
-    description: "Filter API responses based on caller's license tier"
-
-# Enforcement rules
-enforcement:
-  # Startup validation
-  validate_on_startup:
-    enabled: true
-    fail_on_missing_licenses: true
-
-  # Runtime enforcement
-  enforce_at_runtime:
-    enabled: true
-    log_violations: true
-    block_violations: true
-
-  # Audit logging
-  audit_license_access:
-    enabled: true
-    log_redactions: true
-    log_access_denials: true
-
-# Default license tiers
-default_tiers:
-  internal: "affiliate"  # Internal use gets highest tier
-  member: "member"
-  affiliate: "affiliate"
-  public: "public"
-
-# Geographic restrictions
-geographic_restrictions:
-  # EU GDPR considerations
-  eu_data_residency:
-    enabled: false  # Not implemented in v1.0
-    regions: ["EU", "EEA", "UK"]
-
-  # Country-specific restrictions
-  country_specific:
-    china:
-      snomed_ct: "restricted"
-      umls: "restricted"
-    russia:
-      snomed_ct: "restricted"
-      umls: "restricted"
-
-# License validation endpoints
-validation_endpoints:
-  snomed_ct:
-    url: "https://www.snomed.org/snomed-ct/get-snomed-ct"
-    method: "GET"
-  umls:
-    url: "https://uts.nlm.nih.gov/uts/"
-    method: "GET"
-  meddra:
-    url: "https://www.meddra.org/"
-    method: "GET"
-
-# Attribution notices
-attribution_notices:
-  snomed_ct: "This material includes SNOMED Clinical Terms® (SNOMED CT®) which is used by permission of the International Health Terminology Standards Development Organisation (IHTSDO). All rights reserved. SNOMED CT® was originally created by The College of American Pathologists. 'SNOMED' and 'SNOMED CT' are registered trademarks of the IHTSDO."
-  umls: "This product uses data provided by the Unified Medical Language System (UMLS), a service of the National Library of Medicine (NLM), National Institutes of Health (NIH)."
-  meddra: "MedDRA® is a registered trademark of the International Federation of Pharmaceutical Manufacturers and Associations (IFPMA)."
-
-# Policy compliance
-compliance:
-  gdpr_compliant: false  # Not implemented in v1.0
-  hipaa_compliant: false  # Not implemented in v1.0
-  sox_compliant: false    # Not applicable
-  audit_retention_days: 2555  # 7 years
-
+{
+  "vocabs": {
+    "SNOMED": {
+      "licensed": false,
+      "territory": "US"
+    },
+    "MedDRA": {
+      "licensed": true,
+      "territory": "US"
+    },
+    "LOINC": {
+      "licensed": true
+    },
+    "RxNorm": {
+      "licensed": true
+    },
+    "HPO": {
+      "licensed": true
+    }
+  },
+  "actions": {
+    "redact_unlicensed_codes": true,
+    "block_kg_write_without_provenance": true,
+    "fail_on_unlicensed_usage": true
+  }
+}
diff --git a/src/Medical_KG/ingestion/__init__.py b/src/Medical_KG/ingestion/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..b36da04b9494409695744e1ac5f9a1678bbd5bf3
--- /dev/null
+++ b/src/Medical_KG/ingestion/__init__.py
@@ -0,0 +1,12 @@
+"""Ingestion subsystem for external data sources."""
+
+from .http_client import AsyncHttpClient
+from .ledger import IngestionLedger
+from .models import Document, IngestionResult
+
+__all__ = [
+    "AsyncHttpClient",
+    "IngestionLedger",
+    "Document",
+    "IngestionResult",
+]
diff --git a/src/Medical_KG/ingestion/adapters/base.py b/src/Medical_KG/ingestion/adapters/base.py
new file mode 100644
index 0000000000000000000000000000000000000000..456f813d63b581716d8dadb2c5537ea5b1f4b7ae
--- /dev/null
+++ b/src/Medical_KG/ingestion/adapters/base.py
@@ -0,0 +1,70 @@
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from collections.abc import AsyncIterator, Iterable
+from dataclasses import dataclass
+from datetime import datetime, timezone
+from typing import Any, Mapping
+
+from Medical_KG.ingestion.ledger import IngestionLedger
+from Medical_KG.ingestion.models import Document, IngestionResult
+from Medical_KG.ingestion.utils import generate_doc_id
+
+
+@dataclass(slots=True)
+class AdapterContext:
+    ledger: IngestionLedger
+
+
+class BaseAdapter(ABC):
+    source: str
+
+    def __init__(self, context: AdapterContext) -> None:
+        self.context = context
+
+    async def run(self, *args: Any, **kwargs: Any) -> Iterable[IngestionResult]:
+        results: list[IngestionResult] = []
+        async for raw_record in self.fetch(*args, **kwargs):
+            document: Document | None = None
+            try:
+                document = self.parse(raw_record)
+                self.context.ledger.record(
+                    doc_id=document.doc_id,
+                    state="auto_inflight",
+                    metadata={"source": document.source},
+                )
+                self.validate(document)
+                result = await self.write(document)
+            except Exception as exc:  # pragma: no cover - surfaced to caller
+                doc_id = document.doc_id if document else str(raw_record)
+                self.context.ledger.record(
+                    doc_id=doc_id,
+                    state="auto_failed",
+                    metadata={"error": str(exc)},
+                )
+                raise
+            results.append(result)
+        return results
+
+    @abstractmethod
+    async def fetch(self, *args: Any, **kwargs: Any) -> AsyncIterator[Any]:
+        """Yield raw records from the upstream API."""
+
+    @abstractmethod
+    def parse(self, raw: Any) -> Document:
+        """Transform a raw record into a :class:`Document`."""
+
+    @abstractmethod
+    def validate(self, document: Document) -> None:
+        """Perform source-specific validations."""
+
+    async def write(self, document: Document) -> IngestionResult:
+        entry = self.context.ledger.record(
+            doc_id=document.doc_id,
+            state="auto_done",
+            metadata={"source": document.source},
+        )
+        return IngestionResult(document=document, state=entry.state, timestamp=entry.timestamp)
+
+    def build_doc_id(self, *, identifier: str, version: str, content: bytes) -> str:
+        return generate_doc_id(self.source, identifier, version, content)
diff --git a/src/Medical_KG/ingestion/adapters/http.py b/src/Medical_KG/ingestion/adapters/http.py
new file mode 100644
index 0000000000000000000000000000000000000000..15c94f270fbb1b226950532de368abacc7355246
--- /dev/null
+++ b/src/Medical_KG/ingestion/adapters/http.py
@@ -0,0 +1,26 @@
+from __future__ import annotations
+
+from collections.abc import AsyncIterator
+from typing import Any, Mapping
+
+from Medical_KG.ingestion.adapters.base import AdapterContext, BaseAdapter
+from Medical_KG.ingestion.http_client import AsyncHttpClient
+
+
+class HttpAdapter(BaseAdapter):
+    """Base class for HTTP-backed ingestion adapters."""
+
+    def __init__(self, context: AdapterContext, client: AsyncHttpClient) -> None:
+        super().__init__(context)
+        self.client = client
+
+    async def fetch_json(self, url: str, *, params: Mapping[str, Any] | None = None, headers: Mapping[str, str] | None = None) -> Any:
+        return await self.client.get_json(url, params=params, headers=headers)
+
+    async def fetch_text(self, url: str, *, params: Mapping[str, Any] | None = None, headers: Mapping[str, str] | None = None) -> str:
+        return await self.client.get_text(url, params=params, headers=headers)
+
+    async def fetch_bytes(
+        self, url: str, *, params: Mapping[str, Any] | None = None, headers: Mapping[str, str] | None = None
+    ) -> bytes:
+        return await self.client.get_bytes(url, params=params, headers=headers)
diff --git a/src/Medical_KG/ingestion/adapters/literature.py b/src/Medical_KG/ingestion/adapters/literature.py
new file mode 100644
index 0000000000000000000000000000000000000000..10d6c5999a27c618f0c48baedcdfe44b53e26b18
--- /dev/null
+++ b/src/Medical_KG/ingestion/adapters/literature.py
@@ -0,0 +1,133 @@
+from __future__ import annotations
+
+import re
+from collections.abc import AsyncIterator
+from typing import Any
+
+from bs4 import BeautifulSoup
+
+from Medical_KG.ingestion.adapters.base import AdapterContext
+from Medical_KG.ingestion.adapters.http import HttpAdapter
+from Medical_KG.ingestion.http_client import AsyncHttpClient
+from Medical_KG.ingestion.models import Document
+from Medical_KG.ingestion.utils import canonical_json, normalize_text
+
+PUBMED_SEARCH_URL = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi"
+PUBMED_SUMMARY_URL = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi"
+PMC_LIST_URL = "https://www.ncbi.nlm.nih.gov/pmc/oai/oai.cgi"
+MEDRXIV_URL = "https://api.medrxiv.org/details/medrxiv"
+
+PMID_RE = re.compile(r"^\d{4,}")
+PMCID_RE = re.compile(r"^PMC\d+")
+
+
+class PubMedAdapter(HttpAdapter):
+    source = "pubmed"
+
+    def __init__(self, context: AdapterContext, client: AsyncHttpClient, *, api_key: str | None = None) -> None:
+        super().__init__(context, client)
+        self.api_key = api_key
+
+    async def fetch(self, term: str, retmax: int = 100) -> AsyncIterator[Any]:
+        params = {"db": "pubmed", "retmode": "json", "retmax": retmax, "term": term}
+        if self.api_key:
+            params["api_key"] = self.api_key
+        search = await self.fetch_json(PUBMED_SEARCH_URL, params=params)
+        ids = search["esearchresult"].get("idlist", [])
+        if not ids:
+            return
+        summary_params = {"db": "pubmed", "retmode": "json", "id": ",".join(ids)}
+        if self.api_key:
+            summary_params["api_key"] = self.api_key
+        summary = await self.fetch_json(PUBMED_SUMMARY_URL, params=summary_params)
+        result = summary.get("result", {})
+        for uid in result.get("uids", []):
+            data = result.get(uid)
+            if data:
+                yield data
+
+    def parse(self, raw: Any) -> Document:
+        uid = raw.get("uid") or raw["articleids"][0]["value"]
+        title = normalize_text(raw.get("title", ""))
+        abstract = normalize_text(raw.get("elocationid", ""))
+        payload = {
+            "pmid": uid,
+            "title": title,
+            "abstract": abstract,
+            "pubdate": raw.get("pubdate"),
+        }
+        content = canonical_json(payload)
+        doc_id = self.build_doc_id(identifier=uid, version=raw.get("sortpubdate", "unknown"), content=content)
+        metadata = {
+            "title": title,
+            "pub_date": raw.get("pubdate"),
+            "journal": raw.get("fulljournalname"),
+        }
+        return Document(doc_id=doc_id, source=self.source, content=abstract or title, metadata=metadata, raw=payload)
+
+    def validate(self, document: Document) -> None:
+        pmid = document.raw["pmid"]  # type: ignore[index]
+        if not PMID_RE.match(str(pmid)):
+            raise ValueError(f"Invalid PMID: {pmid}")
+
+
+class PmcAdapter(HttpAdapter):
+    source = "pmc"
+
+    async def fetch(self, set_spec: str, *, metadata_prefix: str = "oai_dc") -> AsyncIterator[Any]:
+        params = {"verb": "ListRecords", "set": set_spec, "metadataPrefix": metadata_prefix}
+        xml = await self.fetch_text(PMC_LIST_URL, params=params)
+        soup = BeautifulSoup(xml, "xml")
+        for record in soup.find_all("record"):
+            yield record
+
+    def parse(self, raw: Any) -> Document:
+        header = raw.find("header")
+        identifier = header.find("identifier").text  # type: ignore[assignment]
+        pmcid = identifier.split(":")[-1]
+        metadata = raw.find("metadata")
+        title = metadata.find("title").text if metadata else ""
+        description = metadata.find("description").text if metadata else ""
+        payload = {
+            "pmcid": pmcid,
+            "title": normalize_text(title),
+            "description": normalize_text(description),
+        }
+        content = canonical_json(payload)
+        doc_id = self.build_doc_id(identifier=pmcid, version=header.find("datestamp").text, content=content)  # type: ignore[arg-type]
+        meta = {"title": payload["title"], "datestamp": header.find("datestamp").text}
+        return Document(doc_id=doc_id, source=self.source, content=payload["description"] or payload["title"], metadata=meta, raw=payload)
+
+    def validate(self, document: Document) -> None:
+        pmcid = document.raw["pmcid"]  # type: ignore[index]
+        if not PMCID_RE.match(pmcid):
+            raise ValueError(f"Invalid PMCID: {pmcid}")
+
+
+class MedRxivAdapter(HttpAdapter):
+    source = "medrxiv"
+
+    async def fetch(self, start: int = 0, chunk: int = 100) -> AsyncIterator[Any]:
+        params = {"from": start, "chunk": chunk}
+        payload = await self.fetch_json(MEDRXIV_URL, params=params)
+        for record in payload.get("results", []):
+            yield record
+
+    def parse(self, raw: Any) -> Document:
+        identifier = raw["doi"]
+        title = normalize_text(raw.get("title", ""))
+        abstract = normalize_text(raw.get("abstract", ""))
+        payload = {
+            "doi": identifier,
+            "title": title,
+            "abstract": abstract,
+            "date": raw.get("date"),
+        }
+        content = canonical_json(payload)
+        doc_id = self.build_doc_id(identifier=identifier, version=raw.get("version", "1"), content=content)
+        metadata = {"title": title, "authors": raw.get("authors", [])}
+        return Document(doc_id=doc_id, source=self.source, content=abstract or title, metadata=metadata, raw=payload)
+
+    def validate(self, document: Document) -> None:
+        if "/" not in document.raw["doi"]:  # type: ignore[index]
+            raise ValueError("Invalid DOI")
diff --git a/src/Medical_KG/ingestion/http_client.py b/src/Medical_KG/ingestion/http_client.py
new file mode 100644
index 0000000000000000000000000000000000000000..ee15d9c2662235e9425a14440e15e54820e7801e
--- /dev/null
+++ b/src/Medical_KG/ingestion/http_client.py
@@ -0,0 +1,155 @@
+from __future__ import annotations
+import asyncio
+from collections import deque
+from contextlib import asynccontextmanager
+from dataclasses import dataclass
+from time import time
+from typing import Any, AsyncIterator, Dict, Mapping, MutableMapping
+from urllib.parse import urlparse
+
+import httpx
+
+try:  # pragma: no cover - optional dependency
+    from prometheus_client import Counter, Histogram
+except ModuleNotFoundError:  # pragma: no cover - fallback in tests
+    class _NoopMetric:
+        def labels(self, *args: Any, **kwargs: Any) -> "_NoopMetric":
+            return self
+
+        def inc(self, *_args: Any, **_kwargs: Any) -> None:  # pragma: no cover - noop
+            return None
+
+        def observe(self, *_args: Any, **_kwargs: Any) -> None:  # pragma: no cover - noop
+            return None
+
+    def Counter(*_args: Any, **_kwargs: Any) -> _NoopMetric:  # type: ignore
+        return _NoopMetric()
+
+    def Histogram(*_args: Any, **_kwargs: Any) -> _NoopMetric:  # type: ignore
+        return _NoopMetric()
+
+HTTP_REQUESTS = Counter(
+    "ingest_http_requests_total",
+    "Number of HTTP requests made by the ingestion system",
+    labelnames=("method", "host", "status"),
+)
+HTTP_LATENCY = Histogram(
+    "ingest_http_request_duration_seconds",
+    "Latency of HTTP requests made by the ingestion system",
+    buckets=(0.1, 0.3, 0.6, 1.0, 2.0, 5.0, 10.0),
+)
+
+
+@dataclass(slots=True)
+class RateLimit:
+    rate: int
+    per: float
+
+
+class _SimpleLimiter:
+    def __init__(self, rate: int, per: float) -> None:
+        self.rate = rate
+        self.per = per
+        self._events: deque[float] = deque()
+        self._lock = asyncio.Lock()
+
+    async def __aenter__(self) -> "_SimpleLimiter":
+        await self.acquire()
+        return self
+
+    async def __aexit__(self, *_exc: Any) -> None:
+        return None
+
+    async def acquire(self) -> None:
+        async with self._lock:
+            now = time()
+            while self._events and now - self._events[0] >= self.per:
+                self._events.popleft()
+            if len(self._events) >= self.rate:
+                wait_time = self.per - (now - self._events[0])
+                await asyncio.sleep(max(wait_time, 0))
+                now = time()
+                while self._events and now - self._events[0] >= self.per:
+                    self._events.popleft()
+            self._events.append(time())
+
+
+class AsyncHttpClient:
+    """HTTP client with retries, rate limiting, and observability."""
+
+    def __init__(
+        self,
+        *,
+        timeout: float = 30.0,
+        retries: int = 3,
+        limits: Mapping[str, RateLimit] | None = None,
+        default_rate: RateLimit | None = None,
+        headers: MutableMapping[str, str] | None = None,
+    ) -> None:
+        self._client = httpx.AsyncClient(timeout=timeout, headers=headers, http2=True)
+        self._limits = limits or {}
+        self._default_rate = default_rate or RateLimit(rate=5, per=1.0)
+        self._limiters: Dict[str, _SimpleLimiter] = {}
+        self._retries = retries
+
+    async def aclose(self) -> None:
+        await self._client.aclose()
+
+    def _get_limiter(self, host: str) -> _SimpleLimiter:
+        if host not in self._limiters:
+            limit = self._limits.get(host, self._default_rate)
+            self._limiters[host] = _SimpleLimiter(limit.rate, limit.per)
+        return self._limiters[host]
+
+    async def _execute(self, method: str, url: str, **kwargs: Any) -> httpx.Response:
+        parsed = urlparse(url)
+        limiter = self._get_limiter(parsed.netloc)
+
+        async with limiter:
+            backoff = 0.5
+            last_error: Exception | None = None
+            for _ in range(self._retries):
+                try:
+                    start = time()
+                    response = await self._client.request(method, url, **kwargs)
+                    HTTP_REQUESTS.labels(method, parsed.netloc, str(response.status_code)).inc()
+                    HTTP_LATENCY.observe(time() - start)
+                    response.raise_for_status()
+                    return response
+                except httpx.HTTPError as exc:  # pragma: no cover - exercised via tests
+                    last_error = exc
+                    HTTP_REQUESTS.labels(method, parsed.netloc, exc.__class__.__name__).inc()
+                    await asyncio.sleep(backoff)
+                    backoff = min(backoff * 2, 5.0)
+            if last_error:
+                raise last_error
+            raise RuntimeError("Retry loop exhausted")
+
+    async def get(self, url: str, *, params: Mapping[str, Any] | None = None, headers: Mapping[str, str] | None = None) -> httpx.Response:
+        return await self._execute("GET", url, params=params, headers=headers)
+
+    async def post(self, url: str, *, data: Any | None = None, json: Any | None = None, headers: Mapping[str, str] | None = None) -> httpx.Response:
+        return await self._execute("POST", url, data=data, json=json, headers=headers)
+
+    @asynccontextmanager
+    async def stream(self, method: str, url: str, **kwargs: Any) -> AsyncIterator[httpx.Response]:
+        parsed = urlparse(url)
+        limiter = self._get_limiter(parsed.netloc)
+        async with limiter:
+            async with self._client.stream(method, url, **kwargs) as response:
+                HTTP_REQUESTS.labels(method, parsed.netloc, str(response.status_code)).inc()
+                HTTP_LATENCY.observe(response.elapsed.total_seconds() if response.elapsed else 0.0)
+                response.raise_for_status()
+                yield response
+
+    async def get_json(self, url: str, *, params: Mapping[str, Any] | None = None, headers: Mapping[str, str] | None = None) -> Any:
+        response = await self.get(url, params=params, headers=headers)
+        return response.json()
+
+    async def get_text(self, url: str, *, params: Mapping[str, Any] | None = None, headers: Mapping[str, str] | None = None) -> str:
+        response = await self.get(url, params=params, headers=headers)
+        return response.text
+
+    async def get_bytes(self, url: str, *, params: Mapping[str, Any] | None = None, headers: Mapping[str, str] | None = None) -> bytes:
+        response = await self.get(url, params=params, headers=headers)
+        return response.content
diff --git a/src/Medical_KG/ingestion/ledger.py b/src/Medical_KG/ingestion/ledger.py
new file mode 100644
index 0000000000000000000000000000000000000000..08d57716a8e15e0b912e301aae417b8d1886fc17
--- /dev/null
+++ b/src/Medical_KG/ingestion/ledger.py
@@ -0,0 +1,65 @@
+from __future__ import annotations
+
+from dataclasses import dataclass
+from datetime import datetime, timezone
+from pathlib import Path
+from threading import Lock
+from typing import Any, Dict, Iterable, Mapping, MutableMapping
+
+import jsonlines
+
+
+@dataclass(slots=True)
+class LedgerEntry:
+    doc_id: str
+    state: str
+    timestamp: datetime
+    metadata: Mapping[str, Any]
+
+
+class IngestionLedger:
+    """Durable JSONL-backed ledger tracking ingestion state transitions."""
+
+    def __init__(self, path: Path) -> None:
+        self._path = path
+        self._lock = Lock()
+        self._latest: Dict[str, LedgerEntry] = {}
+        if path.exists():
+            with jsonlines.open(path, mode="r") as reader:
+                for row in reader:
+                    entry = LedgerEntry(
+                        doc_id=row["doc_id"],
+                        state=row["state"],
+                        timestamp=datetime.fromisoformat(row["timestamp"]),
+                        metadata=row.get("metadata", {}),
+                    )
+                    self._latest[entry.doc_id] = entry
+
+    def record(self, doc_id: str, state: str, metadata: Mapping[str, Any] | None = None) -> LedgerEntry:
+        entry = LedgerEntry(
+            doc_id=doc_id,
+            state=state,
+            timestamp=datetime.now(timezone.utc),
+            metadata=metadata or {},
+        )
+        payload = {
+            "doc_id": entry.doc_id,
+            "state": entry.state,
+            "timestamp": entry.timestamp.isoformat(),
+            "metadata": entry.metadata,
+        }
+        with self._lock:
+            self._path.parent.mkdir(parents=True, exist_ok=True)
+            with jsonlines.open(self._path, mode="a") as writer:
+                writer.write(payload)
+            self._latest[doc_id] = entry
+        return entry
+
+    def get(self, doc_id: str) -> LedgerEntry | None:
+        return self._latest.get(doc_id)
+
+    def entries(self, *, state: str | None = None) -> Iterable[LedgerEntry]:
+        entries = self._latest.values()
+        if state is None:
+            return list(entries)
+        return [entry for entry in entries if entry.state == state]
diff --git a/src/Medical_KG/ingestion/models.py b/src/Medical_KG/ingestion/models.py
new file mode 100644
index 0000000000000000000000000000000000000000..62a4de9f1e0612da021d348a2185ccac651b903b
--- /dev/null
+++ b/src/Medical_KG/ingestion/models.py
@@ -0,0 +1,33 @@
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from datetime import datetime
+from typing import Any, Mapping, MutableMapping
+
+
+@dataclass(slots=True)
+class Document:
+    """Canonical ingestion document representation."""
+
+    doc_id: str
+    source: str
+    content: str
+    metadata: MutableMapping[str, Any] = field(default_factory=dict)
+    raw: Any | None = None
+
+    def as_record(self) -> Mapping[str, Any]:
+        return {
+            "doc_id": self.doc_id,
+            "source": self.source,
+            "content": self.content,
+            "metadata": dict(self.metadata),
+            "raw": self.raw,
+        }
+
+
+@dataclass(slots=True)
+class IngestionResult:
+    document: Document
+    state: str
+    timestamp: datetime
+    metadata: Mapping[str, Any] = field(default_factory=dict)
diff --git a/src/Medical_KG/ingestion/utils.py b/src/Medical_KG/ingestion/utils.py
new file mode 100644
index 0000000000000000000000000000000000000000..d45f79acb5f2c0321f3a11a6e1be1300a3c4cfda
--- /dev/null
+++ b/src/Medical_KG/ingestion/utils.py
@@ -0,0 +1,40 @@
+from __future__ import annotations
+
+import hashlib
+import json
+import re
+import unicodedata
+from typing import Any, Mapping
+
+from langdetect import detect
+
+
+LANGUAGE_PATTERN = re.compile(r"^[a-z]{2}")
+
+
+def normalize_text(value: str) -> str:
+    value = unicodedata.normalize("NFKC", value)
+    value = re.sub(r"\s+", " ", value).strip()
+    return value
+
+
+def detect_language(value: str) -> str:
+    try:
+        language = detect(value)
+    except Exception:  # pragma: no cover - upstream library raises generic exceptions
+        return "unknown"
+    match = LANGUAGE_PATTERN.match(language)
+    return match.group(0) if match else language
+
+
+def hash_content(content: bytes) -> str:
+    return hashlib.sha256(content).hexdigest()
+
+
+def generate_doc_id(source: str, identifier: str, version: str, content: bytes) -> str:
+    digest = hash_content(content)[:12]
+    return f"{source}:{identifier}#{version}:{digest}"
+
+
+def canonical_json(data: Mapping[str, Any]) -> bytes:
+    return json.dumps(data, sort_keys=True, separators=(",", ":")).encode("utf-8")
diff --git a/src/httpx/__init__.py b/src/httpx/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..862f52bff1358d174e8e16128d727c8ca4b3038e
--- /dev/null
+++ b/src/httpx/__init__.py
@@ -0,0 +1,103 @@
+from __future__ import annotations
+
+import json
+from contextlib import asynccontextmanager
+from dataclasses import dataclass, field
+from datetime import timedelta
+from typing import Any, AsyncIterator, Dict, Optional
+
+
+class HTTPError(Exception):
+    """Base HTTP error."""
+
+
+class HTTPStatusError(HTTPError):
+    def __init__(self, message: str, *, request: Request | None = None, response: Response | None = None) -> None:
+        super().__init__(message)
+        self.request = request
+        self.response = response
+
+
+class TimeoutException(HTTPError):
+    def __init__(self, message: str, *, request: Request | None = None) -> None:
+        super().__init__(message)
+        self.request = request
+
+
+@dataclass
+class Request:
+    method: str
+    url: str
+    headers: Dict[str, str] = field(default_factory=dict)
+    data: Any | None = None
+    params: Any | None = None
+
+
+class Response:
+    def __init__(
+        self,
+        *,
+        status_code: int,
+        request: Request | None = None,
+        json: Any | None = None,
+        text: str | None = None,
+        content: bytes | None = None,
+    ) -> None:
+        self.status_code = status_code
+        self.request = request
+        self._json = json
+        self._text = text
+        self._content = content
+        self.elapsed: Optional[timedelta] = None
+
+    def json(self) -> Any:
+        if self._json is not None:
+            return self._json
+        if self._text is not None:
+            return json.loads(self._text)
+        if self._content is not None:
+            return json.loads(self._content.decode("utf-8"))
+        raise ValueError("No JSON payload available")
+
+    @property
+    def text(self) -> str:
+        if self._text is not None:
+            return self._text
+        if self._content is not None:
+            return self._content.decode("utf-8")
+        if self._json is not None:
+            return json.dumps(self._json)
+        return ""
+
+    @property
+    def content(self) -> bytes:
+        if self._content is not None:
+            return self._content
+        return self.text.encode("utf-8")
+
+    def raise_for_status(self) -> None:
+        if self.status_code >= 400:
+            raise HTTPStatusError("HTTP error", request=self.request, response=self)
+
+
+class AsyncBaseTransport:
+    async def handle_async_request(self, request: Request) -> Response:
+        raise NotImplementedError
+
+
+class AsyncClient:
+    def __init__(self, *, timeout: float | None = None, headers: Dict[str, str] | None = None, http2: bool = False) -> None:
+        self.timeout = timeout
+        self.headers = headers or {}
+        self.http2 = http2
+
+    async def request(self, method: str, url: str, **kwargs: Any) -> Response:
+        raise NotImplementedError("Provide transport or monkeypatch request() in tests")
+
+    async def aclose(self) -> None:  # pragma: no cover - compatibility
+        return None
+
+    @asynccontextmanager
+    async def stream(self, method: str, url: str, **kwargs: Any) -> AsyncIterator[Response]:
+        response = await self.request(method, url, **kwargs)
+        yield response
diff --git a/src/jsonlines/__init__.py b/src/jsonlines/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..7fd707585405306b8022b1af23f7f611e1c672ea
--- /dev/null
+++ b/src/jsonlines/__init__.py
@@ -0,0 +1,48 @@
+from __future__ import annotations
+
+import json
+from pathlib import Path
+from typing import Any, Iterable, Iterator, TextIO
+
+
+class _JsonLinesWriter:
+    def __init__(self, handle: TextIO) -> None:
+        self._handle = handle
+
+    def write(self, obj: Any) -> None:
+        self._handle.write(json.dumps(obj) + "\n")
+
+    def close(self) -> None:
+        self._handle.close()
+
+    def __enter__(self) -> "_JsonLinesWriter":  # pragma: no cover - context helper
+        return self
+
+    def __exit__(self, *_exc: Any) -> None:  # pragma: no cover - context helper
+        self.close()
+
+
+class _JsonLinesReader:
+    def __init__(self, handle: TextIO) -> None:
+        self._handle = handle
+
+    def __iter__(self) -> Iterator[Any]:
+        for line in self._handle:
+            if line.strip():
+                yield json.loads(line)
+
+    def close(self) -> None:
+        self._handle.close()
+
+    def __enter__(self) -> "_JsonLinesReader":  # pragma: no cover - context helper
+        return self
+
+    def __exit__(self, *_exc: Any) -> None:  # pragma: no cover - context helper
+        self.close()
+
+
+def open(path: Path, mode: str = "r") -> _JsonLinesReader | _JsonLinesWriter:
+    handle = Path(path).open(mode, encoding="utf-8")
+    if "r" in mode:
+        return _JsonLinesReader(handle)
+    return _JsonLinesWriter(handle)
diff --git a/src/langdetect/__init__.py b/src/langdetect/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..f52a48837169d0472b344bd9a8f453cf472238de
--- /dev/null
+++ b/src/langdetect/__init__.py
@@ -0,0 +1,13 @@
+from __future__ import annotations
+
+import re
+
+_ASCII_RE = re.compile(r"^[\x00-\x7F]+$")
+
+
+def detect(text: str) -> str:
+    if not text:
+        return "unknown"
+    if _ASCII_RE.match(text):
+        return "en"
+    return "unknown"
diff --git a/src/yaml/__init__.py b/src/yaml/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..11f7178986ffe198082b5d8d89334b001f5422b6
--- /dev/null
+++ b/src/yaml/__init__.py
@@ -0,0 +1,15 @@
+"""Minimal YAML shim backed by JSON parsing."""
+from __future__ import annotations
+
+import json
+from typing import Any, IO
+
+
+def safe_load(stream: Any) -> Any:
+    if hasattr(stream, "read"):
+        text = stream.read()
+    else:
+        text = stream
+    if text is None or text == "":
+        return {}
+    return json.loads(text)
diff --git a/tests/config/test_cli.py b/tests/config/test_cli.py
new file mode 100644
index 0000000000000000000000000000000000000000..07bdb908720aefac1a8f860a46acd13c78fe4962
--- /dev/null
+++ b/tests/config/test_cli.py
@@ -0,0 +1,93 @@
+from __future__ import annotations
+
+import shutil
+import sys
+from io import StringIO
+import json
+import shutil
+import sys
+from io import StringIO
+from pathlib import Path
+
+import pytest
+
+from Medical_KG.cli import main
+
+
+@pytest.fixture()
+def cli_config_dir(tmp_path: Path) -> Path:
+    source = Path(__file__).resolve().parents[2] / "src" / "Medical_KG" / "config"
+    target = tmp_path / "config"
+    shutil.copytree(source, target)
+    return target
+
+
+@pytest.fixture(autouse=True)
+def cli_env(monkeypatch: pytest.MonkeyPatch) -> None:
+    monkeypatch.setenv("NCBI_API_KEY", "dev-ncbi")
+    monkeypatch.setenv("PMC_API_KEY", "dev-pmc")
+    monkeypatch.setenv("CTGOV_API_KEY", "dev-ctgov")
+    monkeypatch.setenv("OPEN_FDA_API_KEY", "dev-dailymed")
+    monkeypatch.setenv("CTGOV_SANDBOX_KEY", "sandbox-ctgov")
+    monkeypatch.setenv("OPEN_FDA_SANDBOX_KEY", "sandbox-fda")
+    monkeypatch.setenv("NEO4J_PASSWORD", "graph-password")
+    monkeypatch.setenv("API_JWT_SECRET", "jwt-secret")
+
+
+def _run_cli(args: list[str]) -> tuple[int, str]:
+    buffer = StringIO()
+    stdout = sys.stdout
+    try:
+        sys.stdout = buffer
+        exit_code = main(args)
+    finally:
+        sys.stdout = stdout
+    return exit_code, buffer.getvalue()
+
+
+def test_cli_validate_success(cli_config_dir: Path) -> None:
+    exit_code, output = _run_cli([
+        "config",
+        "validate",
+        "--strict",
+        "--config-dir",
+        str(cli_config_dir),
+    ])
+    assert exit_code == 0
+    assert "Config valid" in output
+
+
+def test_cli_validate_failure_on_invalid_payload(cli_config_dir: Path) -> None:
+    override = cli_config_dir / "config-override.yaml"
+    override.write_text(
+        json.dumps(
+            {
+                "retrieval": {
+                    "fusion": {
+                        "weights": {"bm25": 0.8, "splade": 0.1, "dense": 0.05}
+                    }
+                }
+            },
+            indent=2,
+        )
+    )
+    exit_code, output = _run_cli([
+        "config",
+        "validate",
+        "--strict",
+        "--config-dir",
+        str(cli_config_dir),
+    ])
+    assert exit_code == 1
+    assert "Configuration invalid" in output
+
+
+def test_cli_show_masks_secrets(cli_config_dir: Path) -> None:
+    exit_code, output = _run_cli([
+        "config",
+        "show",
+        "--config-dir",
+        str(cli_config_dir),
+    ])
+    assert exit_code == 0
+    assert "***" in output
diff --git a/tests/config/test_config_manager.py b/tests/config/test_config_manager.py
new file mode 100644
index 0000000000000000000000000000000000000000..0957c94421fda0bfb04c58eac25ed1760a120b65
--- /dev/null
+++ b/tests/config/test_config_manager.py
@@ -0,0 +1,177 @@
+from __future__ import annotations
+
+import base64
+import hashlib
+import hmac
+import json
+import shutil
+from pathlib import Path
+
+import pytest
+
+from Medical_KG.config.manager import ConfigError, ConfigManager, mask_secrets
+
+
+@pytest.fixture()
+def config_dir(tmp_path: Path) -> Path:
+    source = Path(__file__).resolve().parents[2] / "src" / "Medical_KG" / "config"
+    target = tmp_path / "config"
+    shutil.copytree(source, target)
+    return target
+
+
+@pytest.fixture()
+def base_env(monkeypatch: pytest.MonkeyPatch) -> None:
+    monkeypatch.setenv("NCBI_API_KEY", "dev-ncbi")
+    monkeypatch.setenv("PMC_API_KEY", "dev-pmc")
+    monkeypatch.setenv("CTGOV_API_KEY", "dev-ctgov")
+    monkeypatch.setenv("OPEN_FDA_API_KEY", "dev-dailymed")
+    monkeypatch.setenv("CTGOV_SANDBOX_KEY", "sandbox-ctgov")
+    monkeypatch.setenv("OPEN_FDA_SANDBOX_KEY", "sandbox-fda")
+    monkeypatch.setenv("NEO4J_PASSWORD", "graph-password")
+    monkeypatch.setenv("API_JWT_SECRET", "jwt-secret")
+    monkeypatch.setenv("PMC_STAGING_KEY", "stage-pmc")
+    monkeypatch.setenv("NCBI_STAGING_KEY", "stage-ncbi")
+    monkeypatch.setenv("CTGOV_STAGING_KEY", "stage-ctgov")
+    monkeypatch.setenv("OPEN_FDA_STAGING_KEY", "stage-fda")
+    monkeypatch.setenv("PMC_PROD_KEY", "prod-pmc")
+    monkeypatch.setenv("NCBI_PROD_KEY", "prod-ncbi")
+    monkeypatch.setenv("CTGOV_PROD_KEY", "prod-ctgov")
+    monkeypatch.setenv("OPEN_FDA_PROD_KEY", "prod-fda")
+    monkeypatch.setenv("NEO4J_PROD_USER", "neo4j")
+    monkeypatch.setenv("NEO4J_PROD_PASSWORD", "prod-password")
+
+
+def test_config_loads_with_overrides_and_env(config_dir: Path, base_env: None, monkeypatch: pytest.MonkeyPatch) -> None:
+    monkeypatch.setenv("CONFIG_ENV", "dev")
+    monkeypatch.setenv("LOG_LEVEL", "warn")
+    override = config_dir / "config-override.yaml"
+    override.write_text(
+        json.dumps(
+            {
+                "retrieval": {
+                    "fusion": {
+                        "weights": {"bm25": 0.5, "splade": 0.2, "dense": 0.3}
+                    }
+                }
+            },
+            indent=2,
+        )
+    )
+    manager = ConfigManager(base_path=config_dir, env="dev")
+    data = manager.config.data()
+    assert data["observability"]["logging"]["level"] == "warn"
+    assert pytest.approx(data["retrieval"]["fusion"]["weights"]["bm25"]) == 0.5
+    assert manager.config.feature_flags()["extraction_experimental_enabled"] is True
+    assert manager.version.raw
+    assert manager.version.hash
+
+
+def test_hot_reload_updates_non_breaking_fields(config_dir: Path, base_env: None, monkeypatch: pytest.MonkeyPatch) -> None:
+    monkeypatch.setenv("CONFIG_ENV", "dev")
+    manager = ConfigManager(base_path=config_dir, env="dev")
+    initial_version = manager.version.raw
+    override = config_dir / "config-override.yaml"
+    override.write_text(
+        json.dumps(
+            {
+                "retrieval": {
+                    "fusion": {
+                        "weights": {"bm25": 0.6, "splade": 0.1, "dense": 0.3}
+                    }
+                }
+            },
+            indent=2,
+        )
+    )
+    manager.reload()
+    assert manager.config.data()["retrieval"]["fusion"]["weights"]["bm25"] == pytest.approx(0.6)
+    assert manager.version.raw != initial_version
+
+
+def test_hot_reload_rejects_breaking_change(config_dir: Path, base_env: None) -> None:
+    manager = ConfigManager(base_path=config_dir, env="dev")
+    override = config_dir / "config-override.yaml"
+    override.write_text(
+        json.dumps({"embeddings": {"vllm_api_base": "https://new-host"}}, indent=2)
+    )
+    with pytest.raises(ConfigError) as exc:
+        manager.reload()
+    assert "Breaking change requires restart" in str(exc.value)
+
+
+def test_licensing_guard_blocks_unlicensed_vocab(config_dir: Path, base_env: None) -> None:
+    manager = ConfigManager(base_path=config_dir, env="dev")
+    override = config_dir / "config-override.yaml"
+    override.write_text(
+        json.dumps({"catalog": {"vocabs": {"snomed": {"enabled": True}}}}, indent=2)
+    )
+    with pytest.raises(ConfigError) as exc:
+        manager.reload()
+    assert "requires affiliate license" in str(exc.value)
+
+
+def test_feature_flag_adjusts_fusion_weights(config_dir: Path, base_env: None, monkeypatch: pytest.MonkeyPatch) -> None:
+    monkeypatch.setenv("MEDCFG__feature_flags__splade_enabled", "false")
+    manager = ConfigManager(base_path=config_dir, env="dev")
+    weights = manager.config.effective_fusion_weights()
+    assert weights["splade"] == pytest.approx(0.0)
+    assert pytest.approx(weights["bm25"] + weights["dense"]) == 1.0
+
+
+def test_validate_jwt_scope(config_dir: Path, base_env: None) -> None:
+    manager = ConfigManager(base_path=config_dir, env="dev")
+    secret = "jwt-secret"
+    auth = manager.config.auth_settings()
+    payload = {
+        "iss": auth["issuer"],
+        "aud": auth["audience"],
+        "scope": "admin:config other:scope",
+    }
+    token = _encode_jwt(payload, secret)
+    claims = manager.validate_jwt(token)
+    assert claims["scope"].startswith("admin:config")
+    bad_token = _encode_jwt({**payload, "scope": "viewer"}, secret)
+    with pytest.raises(ConfigError):
+        manager.validate_jwt(bad_token)
+
+
+def test_mask_secrets_masks_expected_keys() -> None:
+    masked = mask_secrets(
+        {
+            "api_key": "${SECRET}",
+            "plain": "value",
+            "nested": {"password": "hunter2"},
+            "list": [
+                {"refresh_token": "token"},
+                "value",
+            ],
+        }
+    )
+    assert masked["api_key"] == "***"
+    assert masked["nested"]["password"] == "***"
+    assert masked["plain"] == "value"
+    assert masked["list"][0]["refresh_token"] == "***"
+
+
+def test_env_override_parser_supports_json(config_dir: Path, base_env: None, monkeypatch: pytest.MonkeyPatch) -> None:
+    monkeypatch.setenv("RETRIEVAL_FUSION_WEIGHTS", json.dumps({"bm25": 0.7, "splade": 0.1, "dense": 0.2}))
+    manager = ConfigManager(base_path=config_dir, env="dev")
+    weights = manager.config.data()["retrieval"]["fusion"]["weights"]
+    assert pytest.approx(weights["bm25"]) == 0.7
+    assert pytest.approx(weights["splade"]) == 0.1
+    assert pytest.approx(weights["dense"]) == 0.2
+
+
+def _encode_jwt(payload: dict[str, str], secret: str) -> str:
+    header = {"alg": "HS256", "typ": "JWT"}
+    header_b64 = _b64url_encode(json.dumps(header, separators=(",", ":")).encode("utf-8"))
+    payload_b64 = _b64url_encode(json.dumps(payload, separators=(",", ":")).encode("utf-8"))
+    signing_input = f"{header_b64}.{payload_b64}".encode("utf-8")
+    signature = hmac.new(secret.encode("utf-8"), signing_input, hashlib.sha256).digest()
+    signature_b64 = _b64url_encode(signature)
+    return f"{header_b64}.{payload_b64}.{signature_b64}"
+
+
+def _b64url_encode(data: bytes) -> str:
+    return base64.urlsafe_b64encode(data).decode("utf-8").rstrip("=")
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..fdcbc1fe0b0e07f1d53ead7d660533468e2548e0
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,9 @@
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+ROOT = Path(__file__).resolve().parents[1]
+SRC = ROOT / "src"
+if str(SRC) not in sys.path:
+    sys.path.insert(0, str(SRC))
diff --git a/tests/ingestion/test_http_client.py b/tests/ingestion/test_http_client.py
new file mode 100644
index 0000000000000000000000000000000000000000..618f19834cdcf038251e00a5dcaf9f075538db69
--- /dev/null
+++ b/tests/ingestion/test_http_client.py
@@ -0,0 +1,72 @@
+from __future__ import annotations
+
+import asyncio
+from typing import Any
+
+import httpx
+import pytest
+
+from Medical_KG.ingestion.http_client import AsyncHttpClient, RateLimit
+
+
+class _MockTransport(httpx.AsyncBaseTransport):
+    def __init__(self, responses: list[httpx.Response]) -> None:
+        self._responses = responses
+        self.calls: list[httpx.Request] = []
+
+    async def handle_async_request(self, request: httpx.Request) -> httpx.Response:  # type: ignore[override]
+        self.calls.append(request)
+        response = self._responses.pop(0)
+        if response.status_code >= 400:
+            raise httpx.HTTPStatusError("error", request=request, response=response)
+        return response
+
+
+def test_retry_on_transient_failure(monkeypatch: Any) -> None:
+    responses = [
+        httpx.Response(status_code=502, request=httpx.Request("GET", "https://example.com")),
+        httpx.Response(status_code=200, request=httpx.Request("GET", "https://example.com"), json={"ok": True}),
+    ]
+    transport = _MockTransport(responses)
+
+    async def _request(self: httpx.AsyncClient, method: str, url: str, **kwargs: Any) -> httpx.Response:
+        return await transport.handle_async_request(httpx.Request(method, url, **kwargs))
+
+    client = AsyncHttpClient(retries=2, limits={"example.com": RateLimit(rate=5, per=1)})
+    monkeypatch.setattr(client._client, "request", _request.__get__(client._client, httpx.AsyncClient))
+
+    payload = asyncio.run(client.get_json("https://example.com"))
+    assert payload == {"ok": True}
+    assert len(transport.calls) == 2
+
+
+def test_rate_limiter_serializes_calls(monkeypatch: Any) -> None:
+    calls: list[float] = []
+
+    async def _request(self: httpx.AsyncClient, method: str, url: str, **kwargs: Any) -> httpx.Response:
+        calls.append(asyncio.get_running_loop().time())
+        return httpx.Response(status_code=200, json={"ok": True}, request=httpx.Request(method, url, **kwargs))
+
+    client = AsyncHttpClient(limits={"example.com": RateLimit(rate=1, per=0.5)})
+    monkeypatch.setattr(client._client, "request", _request.__get__(client._client, httpx.AsyncClient))
+
+    async def _run() -> None:
+        await asyncio.gather(*(client.get_json("https://example.com") for _ in range(3)))
+
+    asyncio.run(_run())
+    assert len(calls) == 3
+    assert all(b >= a for a, b in zip(calls, calls[1:]))
+
+
+def test_timeout_propagates(monkeypatch: Any) -> None:
+    async def _request(self: httpx.AsyncClient, method: str, url: str, **kwargs: Any) -> httpx.Response:
+        raise httpx.TimeoutException("timeout", request=httpx.Request(method, url))
+
+    client = AsyncHttpClient()
+    monkeypatch.setattr(client._client, "request", _request.__get__(client._client, httpx.AsyncClient))
+
+    async def _call() -> None:
+        await client.get_json("https://example.com")
+
+    with pytest.raises(httpx.TimeoutException):
+        asyncio.run(_call())
diff --git a/tests/ingestion/test_ledger.py b/tests/ingestion/test_ledger.py
new file mode 100644
index 0000000000000000000000000000000000000000..2ecd1ecd54427ab2dd4d1e45c732775525ddef37
--- /dev/null
+++ b/tests/ingestion/test_ledger.py
@@ -0,0 +1,26 @@
+from __future__ import annotations
+
+from pathlib import Path
+
+from Medical_KG.ingestion.ledger import IngestionLedger
+
+
+def test_ledger_persists_entries(tmp_path: Path) -> None:
+    ledger_path = tmp_path / "ledger.jsonl"
+    ledger = IngestionLedger(ledger_path)
+    ledger.record("doc1", "auto_done", {"source": "pubmed"})
+    ledger.record("doc2", "pdf_downloaded", {"source": "pmc"})
+
+    reloaded = IngestionLedger(ledger_path)
+    assert reloaded.get("doc1").state == "auto_done"  # type: ignore[union-attr]
+    assert reloaded.get("doc2").state == "pdf_downloaded"  # type: ignore[union-attr]
+
+
+def test_ledger_entries_returns_latest(tmp_path: Path) -> None:
+    ledger = IngestionLedger(tmp_path / "ledger.jsonl")
+    ledger.record("doc1", "auto_inflight")
+    ledger.record("doc1", "auto_done")
+    entries = {entry.doc_id: entry.state for entry in ledger.entries()}
+    assert entries == {"doc1": "auto_done"}
+    pdf_entries = list(ledger.entries(state="pdf_downloaded"))
+    assert pdf_entries == []
diff --git a/tests/ingestion/test_utils.py b/tests/ingestion/test_utils.py
new file mode 100644
index 0000000000000000000000000000000000000000..f2e43f288a6879822d935725bfb34b00a510168e
--- /dev/null
+++ b/tests/ingestion/test_utils.py
@@ -0,0 +1,22 @@
+from __future__ import annotations
+
+from Medical_KG.ingestion import utils
+
+
+def test_normalize_text_strips_and_canonicalizes() -> None:
+    assert utils.normalize_text(" Café\n") == "Café"
+
+
+def test_detect_language_handles_failure(monkeypatch) -> None:
+    def _fail(_value: str) -> str:
+        raise RuntimeError("boom")
+
+    monkeypatch.setattr(utils, "detect", _fail)
+    assert utils.detect_language("text") == "unknown"
+
+
+def test_generate_doc_id_uses_hash() -> None:
+    content = b"example"
+    doc_id = utils.generate_doc_id("source", "id", "v1", content)
+    assert doc_id.startswith("source:id#v1:")
+    assert len(doc_id.split(":")[-1]) == 12

EOF
)
