"""Telemetry primitives for the asynchronous HTTP client."""

from __future__ import annotations

import importlib.util
import logging
from dataclasses import asdict, dataclass
from time import time
from typing import Any, Callable, Mapping, MutableMapping, Protocol, Sequence, cast
from uuid import uuid4

from Medical_KG.utils.optional_dependencies import (
    CounterProtocol,
    GaugeProtocol,
    HistogramProtocol,
    build_counter,
    build_gauge,
    build_histogram,
)


@dataclass(slots=True)
class HttpEvent:
    """Base event describing an HTTP interaction."""

    request_id: str
    url: str
    method: str
    host: str
    timestamp: float


@dataclass(slots=True)
class HttpRequestEvent(HttpEvent):
    """Event emitted immediately before issuing an HTTP request."""

    headers: Mapping[str, str]


@dataclass(slots=True)
class HttpResponseEvent(HttpEvent):
    """Event emitted once an HTTP response is received."""

    status_code: int
    duration_seconds: float
    response_size_bytes: int
    headers: Mapping[str, str]


@dataclass(slots=True)
class HttpRetryEvent(HttpEvent):
    """Event emitted when the client retries a request."""

    attempt: int
    delay_seconds: float
    reason: str
    will_retry: bool


@dataclass(slots=True)
class HttpBackoffEvent(HttpEvent):
    """Event emitted when the rate limiter enforces backoff."""

    wait_time_seconds: float
    queue_depth: int
    queue_capacity: int
    queue_saturation: float


@dataclass(slots=True)
class HttpErrorEvent(HttpEvent):
    """Event emitted when the client encounters an exception."""

    error_type: str
    message: str
    retryable: bool


class HttpTelemetry(Protocol):
    """Protocol describing telemetry hooks supported by the HTTP client."""

    def on_request(self, event: HttpRequestEvent) -> None:  # pragma: no cover - implementations only
        """Handle an HTTP request event."""

    def on_response(self, event: HttpResponseEvent) -> None:  # pragma: no cover - implementations only
        """Handle an HTTP response event."""

    def on_retry(self, event: HttpRetryEvent) -> None:  # pragma: no cover - implementations only
        """Handle an HTTP retry event."""

    def on_backoff(self, event: HttpBackoffEvent) -> None:  # pragma: no cover - implementations only
        """Handle a backoff event generated by the rate limiter."""

    def on_error(self, event: HttpErrorEvent) -> None:  # pragma: no cover - implementations only
        """Handle an HTTP error event."""


TelemetryCallback = Callable[[HttpEvent], None]


def generate_request_id() -> str:
    """Return a unique identifier for correlating HTTP events."""

    return uuid4().hex


class LoggingTelemetry:
    """Telemetry helper that records structured logs for HTTP events."""

    def __init__(
        self,
        *,
        logger: logging.Logger | None = None,
        level: int = logging.INFO,
    ) -> None:
        self._logger = logger or logging.getLogger("Medical_KG.ingestion.http")
        self._level = level

    def _log(self, action: str, event: HttpEvent) -> None:
        payload = asdict(event)
        headers = payload.get("headers")
        if isinstance(headers, Mapping):
            payload["headers"] = self._sanitize_headers(headers)
        self._logger.log(
            self._level,
            "%s",
            action,
            extra={"http_event": payload},
        )

    def on_request(self, event: HttpRequestEvent) -> None:
        self._log("http.request", event)

    def on_response(self, event: HttpResponseEvent) -> None:
        self._log("http.response", event)

    def on_retry(self, event: HttpRetryEvent) -> None:
        self._log("http.retry", event)

    def on_backoff(self, event: HttpBackoffEvent) -> None:
        self._log("http.backoff", event)

    def on_error(self, event: HttpErrorEvent) -> None:
        self._log("http.error", event)

    @staticmethod
    def _sanitize_headers(headers: Mapping[str, str]) -> dict[str, str]:
        sanitized: dict[str, str] = {}
        redact = {"authorization", "cookie", "x-api-key"}
        for key, value in headers.items():
            normalized = str(key)
            sanitized[normalized] = (
                "<redacted>" if normalized.lower() in redact else str(value)
            )
        return sanitized


_REQUEST_COUNTER: CounterProtocol = build_counter(
    "http_requests_total",
    "Total HTTP requests issued by AsyncHttpClient",
    ("method", "host", "status"),
)
_DURATION_HISTOGRAM: HistogramProtocol = build_histogram(
    "http_request_duration_seconds",
    "HTTP request latency in seconds",
    buckets=(0.05, 0.1, 0.25, 0.5, 1.0, 2.0, 5.0, 10.0),
    labelnames=("method", "host"),
)
_RESPONSE_SIZE_HISTOGRAM: HistogramProtocol = build_histogram(
    "http_response_size_bytes",
    "Size of HTTP responses in bytes",
    buckets=(256, 1024, 4096, 16384, 65536, 262144, 1048576),
    labelnames=("method", "host"),
)
_BACKOFF_HISTOGRAM: HistogramProtocol = build_histogram(
    "http_backoff_duration_seconds",
    "Wait duration enforced by the HTTP rate limiter",
    buckets=(0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.0, 5.0),
    labelnames=("host",),
)
_QUEUE_DEPTH_GAUGE: GaugeProtocol = build_gauge(
    "http_limiter_queue_depth",
    "Current queue depth for the HTTP rate limiter",
    ("host",),
)
_QUEUE_SATURATION_GAUGE: GaugeProtocol = build_gauge(
    "http_limiter_queue_saturation",
    "Rate limiter queue saturation (0-1)",
    ("host",),
)
_RETRY_COUNTER: CounterProtocol = build_counter(
    "http_retries_total",
    "Total HTTP retries performed",
    ("host", "reason"),
)


class PrometheusTelemetry:
    """Telemetry helper that exports HTTP metrics to Prometheus."""

    def __init__(self) -> None:
        self._enabled = self.is_available()

    @staticmethod
    def is_available() -> bool:
        """Return ``True`` when the Prometheus client is installed."""

        return importlib.util.find_spec("prometheus_client") is not None

    def on_request(self, event: HttpRequestEvent) -> None:  # pragma: no cover - no-op hook
        if not self._enabled:
            return

    def on_response(self, event: HttpResponseEvent) -> None:
        if not self._enabled:
            return
        _REQUEST_COUNTER.labels(
            method=event.method,
            host=event.host,
            status=str(event.status_code),
        ).inc()
        _DURATION_HISTOGRAM.labels(method=event.method, host=event.host).observe(
            event.duration_seconds
        )
        _RESPONSE_SIZE_HISTOGRAM.labels(method=event.method, host=event.host).observe(
            float(event.response_size_bytes)
        )

    def on_retry(self, event: HttpRetryEvent) -> None:
        if not self._enabled:
            return
        _RETRY_COUNTER.labels(host=event.host, reason=event.reason).inc()

    def on_backoff(self, event: HttpBackoffEvent) -> None:
        if not self._enabled:
            return
        _BACKOFF_HISTOGRAM.labels(host=event.host).observe(event.wait_time_seconds)
        _QUEUE_DEPTH_GAUGE.labels(host=event.host).set(float(event.queue_depth))
        _QUEUE_SATURATION_GAUGE.labels(host=event.host).set(event.queue_saturation)

    def on_error(self, event: HttpErrorEvent) -> None:
        if not self._enabled:
            return
        _REQUEST_COUNTER.labels(
            method=event.method,
            host=event.host,
            status=event.error_type,
        ).inc()


class TracingTelemetry:
    """Telemetry helper that emits OpenTelemetry spans for HTTP requests."""

    def __init__(
        self,
        *,
        tracer: Any | None = None,
        span_name: str = "http.request",
    ) -> None:
        self._tracer = tracer
        if self._tracer is None:
            try:  # pragma: no cover - optional dependency
                from opentelemetry import trace

                self._tracer = trace.get_tracer(__name__)
            except ModuleNotFoundError:  # pragma: no cover - optional dependency
                self._tracer = None
        self._span_name = span_name
        self._active_spans: MutableMapping[str, Any] = {}

    def on_request(self, event: HttpRequestEvent) -> None:
        if self._tracer is None:
            return
        span = self._tracer.start_span(
            self._span_name,
            attributes={
                "http.method": event.method,
                "http.url": event.url,
                "http.host": event.host,
            },
            start_time=int(event.timestamp * 1_000_000_000),
        )
        self._active_spans[event.request_id] = span

    def on_response(self, event: HttpResponseEvent) -> None:
        span = self._active_spans.pop(event.request_id, None)
        if span is None:
            return
        span.set_attribute("http.status_code", event.status_code)
        span.set_attribute("http.response_size", event.response_size_bytes)
        span.end(end_time=int((event.timestamp + event.duration_seconds) * 1_000_000_000))

    def on_retry(self, event: HttpRetryEvent) -> None:
        span = self._active_spans.get(event.request_id)
        if span is None:
            return
        span.add_event(
            "http.retry",
            attributes={
                "attempt": event.attempt,
                "delay_seconds": event.delay_seconds,
                "reason": event.reason,
                "will_retry": event.will_retry,
            },
            timestamp=int(time() * 1_000_000_000),
        )

    def on_backoff(self, event: HttpBackoffEvent) -> None:
        span = self._active_spans.get(event.request_id)
        if span is None:
            return
        span.add_event(
            "http.backoff",
            attributes={
                "wait_time_seconds": event.wait_time_seconds,
                "queue_depth": event.queue_depth,
                "queue_capacity": event.queue_capacity,
                "queue_saturation": event.queue_saturation,
            },
            timestamp=int(time() * 1_000_000_000),
        )

    def on_error(self, event: HttpErrorEvent) -> None:
        span = self._active_spans.pop(event.request_id, None)
        if span is None:
            return
        span.record_exception(
            Exception(event.message),
            attributes={
                "error.type": event.error_type,
                "error.retryable": event.retryable,
            },
            timestamp=int(time() * 1_000_000_000),
        )
        span.end()


class CompositeTelemetry:
    """Telemetry helper that fans out events to multiple telemetry handlers."""

    def __init__(
        self,
        *telemetries: HttpTelemetry,
        per_host: Mapping[str, Sequence[HttpTelemetry]] | None = None,
        logger: logging.Logger | None = None,
    ) -> None:
        self._global = list(telemetries)
        self._per_host = {host: list(items) for host, items in (per_host or {}).items()}
        self._logger = logger or logging.getLogger("Medical_KG.ingestion.http.telemetry")

    def _dispatch(self, method_name: str, event: HttpEvent) -> None:
        handlers = list(self._global)
        handlers.extend(self._per_host.get(event.host, []))
        for telemetry in handlers:
            callback = getattr(telemetry, method_name, None)
            if callback is None:
                continue
            typed_callback = cast(Callable[[HttpEvent], None], callback)
            try:
                typed_callback(event)
            except Exception:  # pragma: no cover - defensive logging
                self._logger.exception("Telemetry callback %s failed", method_name)

    def on_request(self, event: HttpRequestEvent) -> None:
        self._dispatch("on_request", event)

    def on_response(self, event: HttpResponseEvent) -> None:
        self._dispatch("on_response", event)

    def on_retry(self, event: HttpRetryEvent) -> None:
        self._dispatch("on_retry", event)

    def on_backoff(self, event: HttpBackoffEvent) -> None:
        self._dispatch("on_backoff", event)

    def on_error(self, event: HttpErrorEvent) -> None:
        self._dispatch("on_error", event)


__all__ = [
    "CompositeTelemetry",
    "HttpBackoffEvent",
    "HttpErrorEvent",
    "HttpEvent",
    "HttpRequestEvent",
    "HttpResponseEvent",
    "HttpRetryEvent",
    "HttpTelemetry",
    "LoggingTelemetry",
    "PrometheusTelemetry",
    "TracingTelemetry",
    "generate_request_id",
]
