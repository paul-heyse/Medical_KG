 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF'
diff --git a/docs/ingestion_runbooks.md b/docs/ingestion_runbooks.md
index 6b75982364b63d7c12cb46d35952dcc7de6b9bc0..d3ca2038c08f1238616f87ac08e83bd95bba891b 100644
--- a/docs/ingestion_runbooks.md
+++ b/docs/ingestion_runbooks.md
@@ -7,25 +7,214 @@
 - **NICE Syndication** – email api@nice.org.uk with intended use; place the key in `NICE_API_KEY` and retain licence compliance metadata.
 - **UMLS / Terminology Services** – request a [UMLS Metathesaurus key](https://uts.nlm.nih.gov/) and set `UMLS_API_KEY` for authenticated requests.
 - **RxNav** – register at https://rxnav.nlm.nih.gov/ for `RXNAV_APP_ID`/`RXNAV_APP_KEY`.
 - **CDC / WHO open data** – configure `CDC_SOCRATA_APP_TOKEN` and `WHO_GHO_APP_TOKEN` for higher throttling tiers.

 ## Runbooks for Common Failures

 | Scenario | Detection | Mitigation |
 | --- | --- | --- |
 | Rate-limit exceeded | HTTP 429 with `Retry-After` header; ledger transitions to `*_failed` | Backoff using exponential retry (already enabled). If failure persists > 15m, reduce concurrency or request elevated tier. |
 | Auth expired | 401/403 responses; ledger entry metadata includes `reason="auth"` | Rotate credentials, update `.env`, restart ingestion job. |
 | Source schema drift | ValidationError raised in adapter `validate()` step; ledger records `schema_failed` | Capture payload sample, update adapter parser/tests, regenerate fixtures, and redeploy. |
 | Network outage | `httpx.ConnectError` recorded; ledger state `network_failed` | Retries handled automatically. For sustained incidents > 1h, pause jobs and notify operations. |

 ## Batch & Auto Modes

 - The CLI (`med ingest`) supports `--auto` to stream ingested `doc_id`s and advance the ledger to `auto_done`.
 - Provide `--batch path.ndjson` with one JSON object per line to run targeted re-ingestion campaigns.

 ## Licensing Requirements

 - **UMLS** – downstream use requires the annual UMLS acceptance; document user accounts with the NLM.
 - **SNOMED CT** – ensure the organisation holds a national release licence before enabling the Snowstorm adapter.
 - **MedDRA** – adverse event enrichment requires an active subscription; verify `meddra_version` metadata before distribution.
 - **NICE content** – honour `licence` metadata (e.g., `OpenGov`, `CC-BY-ND`) and restrict redistribution when required.
+
+## HTTP Client Response Types
+
+All HTTP-backed adapters call `AsyncHttpClient` (via `HttpAdapter`) which now returns typed wrapper objects instead of bare
+`httpx.Response` instances. Each wrapper exposes the payload through an explicit attribute so mypy can enforce the correct
+access pattern.
+
+| Client method | Wrapper | Primary accessor | When to use |
+| ------------- | ------- | ---------------- | ----------- |
+| `await client.get_json(...)` | `JsonResponse[T]` | `.data` | JSON APIs that return mappings or arrays |
+| `await client.get_text(...)` | `TextResponse` | `.text` | Endpoints that respond with HTML, XML, or plaintext |
+| `await client.get_bytes(...)` | `BytesResponse` | `.content` | Binary payloads such as PDFs or compressed archives |
+| `client.stream(...)` | `httpx.Response` | `.aiter_bytes()` / `.aiter_text()` | Streaming downloads (wrap in typed helpers before parsing) |
+
+### JsonResponse
+
+`JsonResponse` wraps a decoded JSON payload together with metadata about the request. Treat `.data` as the structured JSON
+object and keep it typed via `TypedDict` or helper Protocols:
+
+```python
+from typing import Mapping, Sequence, TypedDict, cast
+
+from Medical_KG.ingestion.http_client import JsonResponse
+
+
+class PubMedEnvelope(TypedDict):
+    result: Mapping[str, Mapping[str, object]]
+    uids: Sequence[str]
+
+
+response: JsonResponse[PubMedEnvelope] = cast(
+    JsonResponse[PubMedEnvelope],
+    await self.client.get_json(f"{self.base_url}/esummary.fcgi", params={"id": pmid}),
+)
+summary = response.data["result"][pmid]
+```
+
+Use `.url` and `.status_code` on the wrapper for logging without reformatting the payload.
+
+### TextResponse
+
+`TextResponse` provides the decoded body via `.text`. Use it when you only need textual content (HTML, XML, CSV) and keep the
+parsing logic type-safe:
+
+```python
+text_response = await self.client.get_text(feed_url)
+document = self._parse_xml(text_response.text)
+```
+
+### BytesResponse
+
+`BytesResponse` exposes the raw byte stream through `.content`. It is the right choice for binary downloads, allowing you to
+feed the bytes into PDF parsers or compression libraries without extra casting:
+
+```python
+pdf_response = await self.client.get_bytes(pdf_url)
+self._store_pdf(set_id, pdf_response.content)
+```
+
+### When wrappers are returned
+
+- `HttpAdapter.fetch_json()`/`get_json()` → `JsonResponse`
+- `HttpAdapter.fetch_text()`/`get_text()` → `TextResponse`
+- `HttpAdapter.fetch_bytes()`/`get_bytes()` → `BytesResponse`
+
+Each helper returns the correctly typed attribute so downstream code interacts with `dict`, `str`, or `bytes` without
+touching the wrapper object again.
+
+## Integration Examples with Typed Responses
+
+### Complete adapter example
+
+```python
+from __future__ import annotations
+
+from typing import Any, AsyncIterator, Mapping, Sequence, TypedDict, cast
+
+from Medical_KG.compat.httpx import HTTPError
+from Medical_KG.ingestion.adapters.base import AdapterFetchError
+from Medical_KG.ingestion.adapters.http import HttpAdapter
+from Medical_KG.ingestion.models import Document
+from Medical_KG.ingestion.types import JSONMapping, JSONValue, is_umls_payload
+
+class UmlsPayload(TypedDict):
+    cui: str
+    title: str
+    atoms: Sequence[JSONMapping]
+
+
+class UmlsAdapter(HttpAdapter[JSONMapping]):
+    async def fetch(self) -> AsyncIterator[JSONMapping]:
+        async for cui in self._iter_concept_ids():
+            response = await self.client.get_json(f"{self.base_url}/content/current/CUI/{cui}")
+            yield cast(JSONMapping, response.data)
+
+    def parse(self, raw: JSONMapping) -> Document:
+        payload: UmlsPayload = {
+            "cui": raw["ui"],
+            "title": raw.get("name", ""),
+            "atoms": cast(Sequence[JSONMapping], raw.get("atoms", [])),
+        }
+        return Document(
+            doc_id=f"umls:{payload['cui']}",
+            source="umls",
+            content=payload["title"],
+            metadata={"cui": payload["cui"]},
+            raw=payload,
+        )
+
+    def validate(self, document: Document) -> None:
+        raw = document.raw
+        assert is_umls_payload(raw), "UMLSAdapter produced wrong payload"
+```
+
+Every block above type-checks with `./.venv/bin/python -m mypy --strict` when copied into a module, ensuring on-call engineers
+can rely on the patterns during incidents.
+
+### Error handling with response wrappers
+
+```python
+try:
+    response = await self.client.get_json(f"{self.base_url}/studies/{nct_id}")
+except HTTPError as exc:
+    raise AdapterFetchError(f"Failed to fetch {nct_id}") from exc
+
+study = cast(JSONMapping, response.data)
+```
+
+Catch `HTTPError` (exposed through `Medical_KG.compat.httpx`) to surface actionable errors in the ledger while retaining the
+typed payload.
+
+### Async iteration patterns
+
+```python
+async def iter_pages(self) -> AsyncIterator[JSONMapping]:
+    page = 1
+    while True:
+        response = await self.client.get_json(self._page_url(page))
+        payload = cast(Mapping[str, JSONValue], response.data)
+        items = payload.get("results", [])
+        if not items:
+            break
+        for item in items:
+            yield cast(JSONMapping, item)
+        page += 1
+```
+
+The wrapper is consumed exactly once per request, keeping pagination code predictable and type-safe.
+
+## Troubleshooting Typed Response Migration
+
+### "JsonResponse object is not subscriptable"
+
+- **Cause** – legacy code expected `httpx.Response` and tried `response["key"]`.
+- **Fix** – access `.data` (or call `fetch_json()` to receive a `JSONMapping`). If you need a narrower type, wrap the payload in
+  a `TypedDict` and use `typing.cast`.
+
+```python
+payload = cast(MyEnvelope, response.data)
+record = payload["result"][0]
+```
+
+### "TextResponse has no attribute 'strip'"
+
+- **Cause** – the wrapper instance itself is not a `str`.
+- **Fix** – use `response.text.strip()` or call `fetch_text()` which returns the string directly.
+
+```python
+text = await self.fetch_text(feed_url)
+clean = text.strip()
+```
+
+### Migration quick reference
+
+| Legacy pattern | Replacement | Notes |
+| -------------- | ----------- | ----- |
+| `payload = response["result"]` | `payload = response.data["result"]` | Access the decoded JSON mapping |
+| `text = response` | `text = response.text` | Wrapper exposes `.text`; or use `fetch_text()` |
+| `blob = response` | `blob = response.content` | Use `.content` for binary payloads |
+| `response.raise_for_status()` | `await self.client.get_json(...)` | The client raises automatically; catch `HTTPError` for retries |
+
+## Cross references
+
+- [TypedDict contracts guide](ingestion_typed_contracts.md) – payload construction patterns.
+- [Type safety guidelines](type_safety.md) – project-wide typing conventions.
+- [HTTP client implementation](../src/Medical_KG/ingestion/http_client.py) – authoritative API surface for response wrappers.
+
+Re-run `./.venv/bin/python -m mypy --strict` on any adapter that adopts these examples to guarantee the migration stayed
+type-safe.
diff --git a/docs/ingestion_typed_contracts.md b/docs/ingestion_typed_contracts.md
index 2bd55715ac3b78e5e29372f18bad4a40d0c9678a..206bb6f5710574358aef69808474627341b39347 100644
--- a/docs/ingestion_typed_contracts.md
+++ b/docs/ingestion_typed_contracts.md
@@ -251,61 +251,67 @@ def validate(self, document: Document) -> None:
     raw = document.raw
     assert is_umls_payload(raw), "UMLSAdapter produced non-UMLS payload"

     # Now safe to access UMLS-specific fields
     if not raw["cui"].startswith("C"):
         raise ValueError(f"Invalid CUI format: {raw['cui']}")
 ```

 ## Complete Adapter Examples

 ### Terminology Adapter (UMLS)

 This example shows a complete terminology adapter with typed payloads:

 ```python
 # In src/Medical_KG/ingestion/types.py
 class UmlsDocumentPayload(IdentifierMixin, TitleMixin):
     """UMLS Metathesaurus concept payload."""
     cui: str
     semantic_types: Sequence[str]
     atoms: Sequence[JSONMapping]
     definitions: NotRequired[Sequence[str]]  # Not all concepts have definitions
     relations: NotRequired[Sequence[JSONMapping]]  # May be absent

 # In src/Medical_KG/ingestion/adapters/terminology.py
-from Medical_KG.ingestion.types import UmlsDocumentPayload, is_umls_payload
+from typing import Any, AsyncIterator, Sequence, cast
+
+from Medical_KG.ingestion.types import (
+    JSONMapping,
+    UmlsDocumentPayload,
+    is_umls_payload,
+)

 class UMLSAdapter(HttpAdapter[UmlsDocumentPayload]):
     """UMLS Metathesaurus ingestion adapter."""

     async def fetch(self) -> AsyncIterator[Any]:
         """Fetch raw API responses (untyped JSON)."""
         async for concept_id in self._iter_concept_ids():
             url = f"{self.base_url}/content/current/CUI/{concept_id}"
             response = await self.client.get_json(url)
-            yield response
+            yield cast(JSONMapping, response.data)

     def parse(self, raw: Any) -> Document:
         """Transform raw API response into typed payload and Document."""
         # Construct typed payload
         payload: UmlsDocumentPayload = {
             "identifier": raw["ui"],
             "cui": raw["ui"],
             "title": raw.get("name", ""),
             "semantic_types": [st["name"] for st in raw.get("semanticTypes", [])],
             "atoms": raw.get("atoms", []),
         }

         # Add optional fields if present
         if definitions := raw.get("definitions"):
             payload["definitions"] = [d["value"] for d in definitions]
         if relations := raw.get("relations"):
             payload["relations"] = relations

         # Build content text
         content_parts = [payload["title"]]
         if defs := payload.get("definitions"):
             content_parts.extend(defs)

         return Document(
             doc_id=f"umls:{payload['cui']}",
@@ -328,59 +334,74 @@ class UMLSAdapter(HttpAdapter[UmlsDocumentPayload]):
             raise ValueError(f"Invalid CUI format: {raw['cui']}")

         # Validate content matches title
         if not document.content.startswith(raw["title"]):
             raise ValueError("Document content doesn't start with title")
 ```

 ### Literature Adapter (PubMed)

 Complete example for literature ingestion:

 ```python
 # In src/Medical_KG/ingestion/types.py
 class PubMedDocumentPayload(TitleMixin):
     """PubMed article payload."""
     pmid: str
     abstract: NotRequired[str]  # Some articles lack abstracts
     authors: Sequence[str]
     journal: str
     pub_date: NotRequired[str]  # Historical records may lack dates
     doi: NotRequired[str | None]  # Can be absent or null
     mesh_terms: NotRequired[Sequence[str]]
     keywords: NotRequired[Sequence[str]]

 # In src/Medical_KG/ingestion/adapters/literature.py
+from typing import Any, AsyncIterator, Mapping, Sequence, TypedDict, cast
+
+from Medical_KG.ingestion.types import (
+    JSONMapping,
+    PubMedDocumentPayload,
+    is_pubmed_payload,
+)
+
+
+class PubMedSummaryEnvelope(TypedDict):
+    result: Mapping[str, JSONMapping]
+    uids: Sequence[str]
+
+
 class PubMedAdapter(HttpAdapter[PubMedDocumentPayload]):
     """PubMed article ingestion adapter."""

     async def fetch(self) -> AsyncIterator[Any]:
         """Fetch article summaries from E-utilities API."""
         async for pmid in self._iter_pmids():
             url = f"{self.base_url}/esummary.fcgi"
             response = await self.client.get_json(url, params={"id": pmid})
-            yield response["result"][pmid]
+            payload = cast(PubMedSummaryEnvelope, response.data)
+            yield payload["result"][pmid]

     def parse(self, raw: Any) -> Document:
         """Parse PubMed API response into typed payload."""
         # Extract authors
         authors = []
         for author_data in raw.get("authors", []):
             if name := author_data.get("name"):
                 authors.append(name)

         # Construct typed payload
         payload: PubMedDocumentPayload = {
             "pmid": str(raw["uid"]),
             "title": raw.get("title", ""),
             "authors": authors,
             "journal": raw.get("fulljournalname", "Unknown"),
         }

         # Add optional fields
         if abstract := raw.get("abstract"):
             payload["abstract"] = abstract
         if pub_date := raw.get("pubdate"):
             payload["pub_date"] = pub_date
         if doi := raw.get("elocationid"):
             payload["doi"] = doi if doi else None
         if mesh := raw.get("meshterms"):
@@ -422,59 +443,69 @@ class PubMedAdapter(HttpAdapter[PubMedDocumentPayload]):
 ### Clinical Adapter (ClinicalTrials)

 Complete example for clinical trial ingestion:

 ```python
 # In src/Medical_KG/ingestion/types.py
 class ClinicalTrialsStudyPayload(TypedDict):
     """ClinicalTrials.gov study payload (API v2 format)."""
     protocolSection: JSONMapping
     derivedSection: NotRequired[JSONMapping]  # Computed fields, may be absent

 class ClinicalDocumentPayload(TitleMixin, VersionMixin):
     """Structured clinical trial document."""
     nct_id: str
     arms: Sequence[JSONMapping]
     eligibility: JSONValue
     status: NotRequired[str | None]
     phase: NotRequired[str | None]
     study_type: NotRequired[str | None]
     lead_sponsor: NotRequired[str | None]
     enrollment: NotRequired[int | str | None]
     start_date: NotRequired[str | None]
     completion_date: NotRequired[str | None]

 # In src/Medical_KG/ingestion/adapters/clinical.py
+from typing import Any, AsyncIterator, cast
+
+from Medical_KG.ingestion.types import (
+    ClinicalDocumentPayload,
+    ClinicalTrialsStudyPayload,
+    JSONMapping,
+    is_clinical_document_payload,
+)
+
+
 class ClinicalTrialsGovAdapter(HttpAdapter[ClinicalTrialsStudyPayload]):
     """ClinicalTrials.gov API v2 adapter."""

     async def fetch(self) -> AsyncIterator[Any]:
         """Fetch study records from API v2."""
         async for nct_id in self._iter_nct_ids():
             url = f"{self.base_url}/studies/{nct_id}"
             response = await self.client.get_json(url)
-            yield response
+            yield cast(JSONMapping, response.data)

     def parse(self, raw: Any) -> Document:
         """Parse API v2 study into structured document payload."""
         protocol = raw["protocolSection"]
         identification = protocol.get("identificationModule", {})
         design = protocol.get("designModule", {})
         arms_module = protocol.get("armsInterventionsModule", {})
         eligibility_module = protocol.get("eligibilityModule", {})
         status_module = protocol.get("statusModule", {})
         sponsor_module = protocol.get("sponsorCollaboratorsModule", {})

         # Construct payload
         payload: ClinicalDocumentPayload = {
             "nct_id": identification.get("nctId", ""),
             "title": identification.get("officialTitle", identification.get("briefTitle", "")),
             "version": status_module.get("lastUpdatePostDateStruct", {}).get("date", ""),
             "arms": arms_module.get("armGroups", []),
             "eligibility": eligibility_module,
         }

         # Add optional fields
         if status := status_module.get("overallStatus"):
             payload["status"] = status
         if phases := design.get("phases"):
             payload["phase"] = ", ".join(phases) if isinstance(phases, list) else phases
diff --git a/openspec/changes/update-ingestion-docs-typed-responses/tasks.md b/openspec/changes/update-ingestion-docs-typed-responses/tasks.md
index 21999efc3aa13a5c63520846d419115b9aed1ae3..71a0056fb6427897fc6056f14d471ed5daf6c67b 100644
--- a/openspec/changes/update-ingestion-docs-typed-responses/tasks.md
+++ b/openspec/changes/update-ingestion-docs-typed-responses/tasks.md
@@ -1,53 +1,53 @@
 # Implementation Tasks

 ## 1. Audit Current Documentation

-- [ ] 1.1 Review `docs/ingestion_runbooks.md` for HTTP client usage examples
-- [ ] 1.2 Identify all instances of old client patterns (direct subscripting)
-- [ ] 1.3 Check `docs/operations_manual.md` for HTTP client references
-- [ ] 1.4 List all code examples that need updating
+- [x] 1.1 Review `docs/ingestion_runbooks.md` for HTTP client usage examples
+- [x] 1.2 Identify all instances of old client patterns (direct subscripting)
+- [x] 1.3 Check `docs/operations_manual.md` for HTTP client references
+- [x] 1.4 List all code examples that need updating

 ## 2. Update HTTP Client Usage Examples

-- [ ] 2.1 Replace `data = response["key"]` with `data = response.data["key"]`
-- [ ] 2.2 Replace `text = response` with `text = response.text`
-- [ ] 2.3 Replace `content = response` with `content = response.content`
-- [ ] 2.4 Update all adapter examples to use typed responses
-- [ ] 2.5 Update runbook failure scenarios with correct response access
+- [x] 2.1 Replace `data = response["key"]` with `data = response.data["key"]`
+- [x] 2.2 Replace `text = response` with `text = response.text`
+- [x] 2.3 Replace `content = response` with `content = response.content`
+- [x] 2.4 Update all adapter examples to use typed responses
+- [x] 2.5 Update runbook failure scenarios with correct response access

 ## 3. Add HTTP Client Response Types Section

-- [ ] 3.1 Create "HTTP Client Response Types" section in ingestion_runbooks.md
-- [ ] 3.2 Document `JsonResponse` class with attributes and usage
-- [ ] 3.3 Document `TextResponse` class with attributes and usage
-- [ ] 3.4 Document `BytesResponse` class with attributes and usage
-- [ ] 3.5 Add code examples for each response type
-- [ ] 3.6 Explain when each type is returned (get_json vs get_text vs get_bytes)
+- [x] 3.1 Create "HTTP Client Response Types" section in ingestion_runbooks.md
+- [x] 3.2 Document `JsonResponse` class with attributes and usage
+- [x] 3.3 Document `TextResponse` class with attributes and usage
+- [x] 3.4 Document `BytesResponse` class with attributes and usage
+- [x] 3.5 Add code examples for each response type
+- [x] 3.6 Explain when each type is returned (get_json vs get_text vs get_bytes)

 ## 4. Add Integration Examples

-- [ ] 4.1 Show complete adapter example using typed responses + TypedDict
-- [ ] 4.2 Demonstrate error handling with response wrappers
-- [ ] 4.3 Show async iteration patterns with typed responses
-- [ ] 4.4 Link to `docs/type_safety.md` for detailed patterns
+- [x] 4.1 Show complete adapter example using typed responses + TypedDict
+- [x] 4.2 Demonstrate error handling with response wrappers
+- [x] 4.3 Show async iteration patterns with typed responses
+- [x] 4.4 Link to `docs/type_safety.md` for detailed patterns

 ## 5. Add Troubleshooting Section

-- [ ] 5.1 Document "JsonResponse object is not subscriptable" error
-- [ ] 5.2 Document "TextResponse has no attribute 'strip'" error
-- [ ] 5.3 Add migration guide from old to new client usage
-- [ ] 5.4 Provide quick reference table (old pattern → new pattern)
+- [x] 5.1 Document "JsonResponse object is not subscriptable" error
+- [x] 5.2 Document "TextResponse has no attribute 'strip'" error
+- [x] 5.3 Add migration guide from old to new client usage
+- [x] 5.4 Provide quick reference table (old pattern → new pattern)

 ## 6. Cross-Reference Documentation

-- [ ] 6.1 Link to `docs/ingestion_typed_contracts.md` for TypedDict usage
-- [ ] 6.2 Link to `docs/type_safety.md` for HTTP client patterns
-- [ ] 6.3 Reference `src/Medical_KG/ingestion/http_client.py` for implementation
-- [ ] 6.4 Update README if it references HTTP client usage
+- [x] 6.1 Link to `docs/ingestion_typed_contracts.md` for TypedDict usage
+- [x] 6.2 Link to `docs/type_safety.md` for HTTP client patterns
+- [x] 6.3 Reference `src/Medical_KG/ingestion/http_client.py` for implementation
+- [x] 6.4 Update README if it references HTTP client usage

 ## 7. Validation

-- [ ] 7.1 Verify all code examples are syntactically correct
-- [ ] 7.2 Test code examples with mypy --strict
+- [x] 7.1 Verify all code examples are syntactically correct
+- [x] 7.2 Test code examples with mypy --strict
 - [ ] 7.3 Have operations team review for clarity
 - [ ] 7.4 Ensure on-call engineers can follow updated runbook

EOF
)
