 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF'
diff --git a/openspec/changes/add-http-client-context-manager/tasks.md b/openspec/changes/add-http-client-context-manager/tasks.md
index 37560796526733fef963626dc2461274e0ae114b..159f1bf082c882b31bde8a3684b12612d7dd0b7e 100644
--- a/openspec/changes/add-http-client-context-manager/tasks.md
+++ b/openspec/changes/add-http-client-context-manager/tasks.md
@@ -1,58 +1,58 @@
 # Implementation Tasks

 ## 1. Implement Context Manager Protocol

-- [ ] 1.1 Add `__aenter__` method to `AsyncHttpClient` (returns self)
-- [ ] 1.2 Add `__aexit__` method to `AsyncHttpClient` (calls `aclose()`)
-- [ ] 1.3 Ensure proper exception handling in `__aexit__`
-- [ ] 1.4 Add type hints for context manager protocol
-- [ ] 1.5 Test context manager with exceptions (cleanup still happens)
+- [x] 1.1 Add `__aenter__` method to `AsyncHttpClient` (returns self)
+- [x] 1.2 Add `__aexit__` method to `AsyncHttpClient` (calls `aclose()`)
+- [x] 1.3 Ensure proper exception handling in `__aexit__`
+- [x] 1.4 Add type hints for context manager protocol
+- [x] 1.5 Test context manager with exceptions (cleanup still happens)

 ## 2. Update Core Tests

-- [ ] 2.1 Add test for `async with AsyncHttpClient()` basic usage
-- [ ] 2.2 Add test verifying cleanup happens on success
-- [ ] 2.3 Add test verifying cleanup happens on exception
-- [ ] 2.4 Add test for nested context managers
-- [ ] 2.5 Verify existing manual `aclose()` patterns still work
+- [x] 2.1 Add test for `async with AsyncHttpClient()` basic usage
+- [x] 2.2 Add test verifying cleanup happens on success
+- [x] 2.3 Add test verifying cleanup happens on exception
+- [x] 2.4 Add test for nested context managers
+- [x] 2.5 Verify existing manual `aclose()` patterns still work

 ## 3. Refactor Ingestion Adapters

 - [ ] 3.1 Update `BaseAdapter` to use context manager in examples
 - [ ] 3.2 Refactor terminology adapters (MeSH, UMLS, LOINC, ICD-11, SNOMED)
 - [ ] 3.3 Refactor literature adapters (PubMed, PMC, MedRxiv)
 - [ ] 3.4 Refactor clinical adapters (ClinicalTrials, openFDA, DailyMed, RxNorm)
 - [ ] 3.5 Refactor guideline adapters (NICE, USPSTF, CDC, WHO)
 - [ ] 3.6 Verify all adapters pass tests after refactoring

 ## 4. Refactor Test Suite

-- [ ] 4.1 Update `conftest.py` fixtures to use context managers
-- [ ] 4.2 Refactor adapter tests to use `async with`
-- [ ] 4.3 Refactor HTTP client tests
-- [ ] 4.4 Remove manual `aclose()` calls from tests
-- [ ] 4.5 Simplify test cleanup logic
+- [x] 4.1 Update `conftest.py` fixtures to use context managers
+- [x] 4.2 Refactor adapter tests to use `async with`
+- [x] 4.3 Refactor HTTP client tests
+- [x] 4.4 Remove manual `aclose()` calls from tests
+- [x] 4.5 Simplify test cleanup logic

 ## 5. Optional: Add Synchronous Wrapper

 - [ ] 5.1 Create `HttpClientContext` synchronous context manager class
 - [ ] 5.2 Implement `__enter__` and `__exit__` using `asyncio.run()`
 - [ ] 5.3 Add tests for synchronous wrapper
 - [ ] 5.4 Document when to use sync vs async context managers

 ## 6. Documentation

 - [ ] 6.1 Update `http_client.py` module docstring with context manager examples
 - [ ] 6.2 Add context manager section to ingestion runbooks
 - [ ] 6.3 Create migration guide from manual cleanup to context managers
 - [ ] 6.4 Update adapter creation guide with context manager pattern
 - [ ] 6.5 Add troubleshooting for common context manager mistakes

 ## 7. Validation

 - [ ] 7.1 Run full test suite - all tests pass
 - [ ] 7.2 Verify no resource leaks using memory profiler
 - [ ] 7.3 Test with real API calls (ensure cleanup works)
-- [ ] 7.4 Run mypy --strict - no type errors
+- [x] 7.4 Run mypy --strict - no type errors
 - [ ] 7.5 Verify backward compatibility (old patterns still work)

diff --git a/src/Medical_KG/cli.py b/src/Medical_KG/cli.py
index e17ff30b84bfb5705e47be19e8c757936fcb9a3b..d140982d5c788a49e2fb3c87e7d8578c3de92812 100644
--- a/src/Medical_KG/cli.py
+++ b/src/Medical_KG/cli.py
@@ -206,70 +206,67 @@ def _command_postpdf(args: argparse.Namespace) -> int:
     except ConfigError as exc:
         print(f"Unable to load configuration: {exc}")
         return 1
     pdf_config = manager.config.pdf_pipeline()
     require_gpu = pdf_config.require_gpu
     try:
         ensure_gpu(require_flag=require_gpu)
     except GpuNotAvailableError as exc:
         print(str(exc), file=sys.stderr)
         return 99
     ledger = IngestionLedger(pdf_config.ledger_path.expanduser())
     entries = list(ledger.entries(state="pdf_ir_ready"))
     for entry in entries:
         ledger.record(entry.doc_id, "postpdf_started", {"steps": args.steps})
     print(f"Triggered downstream processing for {len(entries)} document(s)")
     return 0


 def _command_ingest(args: argparse.Namespace) -> int:
     if args.source not in available_sources():
         print(f"Unknown source '{args.source}'. Known sources: {', '.join(available_sources())}")
         return 1

     ledger = IngestionLedger(args.ledger)
     context = AdapterContext(ledger=ledger)
-    client = AsyncHttpClient()
-    adapter = get_adapter(args.source, context, client)

     async def _run() -> None:
-        try:
+        async with AsyncHttpClient() as client:
+            adapter = get_adapter(args.source, context, client)
             if args.batch:
                 with args.batch.open() as handle:
                     for line in handle:
                         if not line.strip():
                             continue
                         params = json.loads(line)
                         results = await adapter.run(**params)
                         if args.auto:
                             print(json.dumps([res.document.doc_id for res in results]))
             else:
                 results = await adapter.run()
                 if args.auto:
                     print(json.dumps([res.document.doc_id for res in results]))
-        finally:
-            await client.aclose()

     asyncio.run(_run())
     return 0


 def build_parser() -> argparse.ArgumentParser:
     parser = argparse.ArgumentParser(prog="med", description="Medical KG command-line tools")
     subparsers = parser.add_subparsers(dest="command", required=True)

     config_parser = subparsers.add_parser("config", help="Configuration commands")
     config_subparsers = config_parser.add_subparsers(dest="config_command", required=True)

     validate = config_subparsers.add_parser("validate", help="Validate configuration files")
     validate.add_argument("--strict", action="store_true", help="Fail on any warning")
     validate.add_argument("--config-dir", type=Path, default=None, help="Config directory")
     validate.set_defaults(func=_command_validate)

     show = config_subparsers.add_parser("show", help="Print effective configuration")
     show.add_argument("--config-dir", type=Path, default=None, help="Config directory")
     show.add_argument("--mask", action="store_true", default=True)
     show.add_argument("--no-mask", dest="mask", action="store_false")
     show.set_defaults(func=_command_show)

     policy = config_subparsers.add_parser("policy", help="Display licensing policy")
     policy.add_argument("--config-dir", type=Path, default=None, help="Config directory")
diff --git a/src/Medical_KG/ingestion/http_client.py b/src/Medical_KG/ingestion/http_client.py
index b22425115130e2644fe0fb2fa4e5cb2f5cd5be8a..d6270e694e0a578abf070ab254da326fe5b14484 100644
--- a/src/Medical_KG/ingestion/http_client.py
+++ b/src/Medical_KG/ingestion/http_client.py
@@ -1,66 +1,77 @@
 from __future__ import annotations

 import asyncio
 import importlib.util
+import logging
 import random
 from collections import deque
 from contextlib import asynccontextmanager
 from dataclasses import dataclass
 from time import time
-from typing import AsyncIterator, Generic, Mapping, MutableMapping, TypeVar, cast
+from types import TracebackType
+from typing import (
+    AsyncIterator,
+    Generic,
+    Mapping,
+    MutableMapping,
+    TypeVar,
+    cast,
+)
 from urllib.parse import urlparse

 from Medical_KG.compat.httpx import (
     AsyncClientProtocol,
     HTTPError,
     ResponseProtocol,
     create_async_client,
 )
 from Medical_KG.ingestion.types import JSONValue
 from Medical_KG.utils.optional_dependencies import (
     CounterProtocol,
     HistogramProtocol,
     HttpxModule,
     build_counter,
     build_histogram,
     get_httpx_module,
 )

 HTTPX: HttpxModule = get_httpx_module()

 HTTP_REQUESTS: CounterProtocol = build_counter(
     "ingest_http_requests_total",
     "Number of HTTP requests made by the ingestion system",
     labelnames=("method", "host", "status"),
 )
 HTTP_LATENCY: HistogramProtocol = build_histogram(
     "ingest_http_request_duration_seconds",
     "Latency of HTTP requests made by the ingestion system",
     buckets=(0.1, 0.3, 0.6, 1.0, 2.0, 5.0, 10.0),
 )

+LOGGER = logging.getLogger(__name__)
+

 @dataclass(slots=True)
 class RateLimit:
     rate: int
     per: float


 JSONBodyT = TypeVar("JSONBodyT", bound=JSONValue)


 @dataclass(slots=True)
 class JsonResponse(Generic[JSONBodyT]):
     url: str
     status_code: int
     data: JSONBodyT


 @dataclass(slots=True)
 class TextResponse:
     url: str
     status_code: int
     text: str


 @dataclass(slots=True)
@@ -100,50 +111,73 @@ class _SimpleLimiter:

 class AsyncHttpClient:
     """HTTP client with retries, rate limiting, and observability."""

     def __init__(
         self,
         *,
         timeout: float = 30.0,
         retries: int = 3,
         limits: Mapping[str, RateLimit] | None = None,
         default_rate: RateLimit | None = None,
         headers: MutableMapping[str, str] | None = None,
     ) -> None:
         http2_enabled = importlib.util.find_spec("h2") is not None
         self._client: AsyncClientProtocol = create_async_client(
             timeout=timeout, headers=headers, http2=http2_enabled
         )
         self._limits: dict[str, RateLimit] = dict(limits or {})
         self._default_rate = default_rate or RateLimit(rate=5, per=1.0)
         self._limiters: dict[str, _SimpleLimiter] = {}
         self._retries = retries

     async def aclose(self) -> None:
         await self._client.aclose()

+    async def __aenter__(self) -> "AsyncHttpClient":
+        return self
+
+    async def __aexit__(
+        self,
+        exc_type: type[BaseException] | None,
+        exc: BaseException | None,
+        traceback: TracebackType | None,
+    ) -> bool:
+        close_error: Exception | None = None
+        try:
+            await self.aclose()
+        except Exception as err:  # pragma: no cover - rare cleanup failure
+            close_error = err
+            if exc is not None:
+                LOGGER.warning(
+                    "AsyncHttpClient cleanup failed during exception handling: %s",
+                    err,
+                )
+        if close_error is not None and exc_type is None:
+            raise close_error
+        return False
+
     def _get_limiter(self, host: str) -> _SimpleLimiter:
         if host not in self._limiters:
             limit = self._limits.get(host, self._default_rate)
             self._limiters[host] = _SimpleLimiter(limit.rate, limit.per)
         return self._limiters[host]

     async def _execute(
         self, method: str, url: str, **kwargs: object
     ) -> ResponseProtocol:
         parsed = urlparse(url)
         limiter = self._get_limiter(parsed.netloc)

         async with limiter:
             backoff = 0.5
             last_error: Exception | None = None
             for _ in range(self._retries):
                 try:
                     start = time()
                     response = await self._client.request(method, url, **kwargs)
                     HTTP_REQUESTS.labels(method=method, host=parsed.netloc, status=str(response.status_code)).inc()
                     HTTP_LATENCY.observe(time() - start)
                     response.raise_for_status()
                     return response
                 except HTTPError as exc:  # pragma: no cover - exercised via tests
                     status = getattr(getattr(exc, "response", None), "status_code", None)
diff --git a/src/Medical_KG/ingestion/pipeline.py b/src/Medical_KG/ingestion/pipeline.py
index dc8fcd6a5543ee519295eb010fa259868ff0e93e..33ee7679f3bed76a53ac880b0e6f11a415bf3343 100644
--- a/src/Medical_KG/ingestion/pipeline.py
+++ b/src/Medical_KG/ingestion/pipeline.py
@@ -1,30 +1,31 @@
 """Pipeline utilities orchestrating adapter execution and resume workflows."""

 from __future__ import annotations

 import asyncio
+from contextlib import AsyncExitStack
 from dataclasses import dataclass
 from typing import Any, Iterable, Protocol

 from Medical_KG.ingestion import registry as ingestion_registry
 from Medical_KG.ingestion.adapters.base import AdapterContext, BaseAdapter
 from Medical_KG.ingestion.http_client import AsyncHttpClient
 from Medical_KG.ingestion.ledger import IngestionLedger


 class AdapterRegistry(Protocol):
     def get_adapter(
         self,
         source: str,
         context: AdapterContext,
         client: AsyncHttpClient,
         **kwargs: Any,
     ) -> BaseAdapter[Any]:
         ...

     def available_sources(self) -> list[str]:
         ...


 @dataclass(slots=True)
 class PipelineResult:
@@ -46,67 +47,76 @@ class IngestionPipeline:
     ) -> None:
         self.ledger = ledger
         self._registry = registry or ingestion_registry
         self._client_factory = client_factory or AsyncHttpClient

     def run(
         self,
         source: str,
         params: Iterable[dict[str, Any]] | None = None,
         *,
         resume: bool = False,
     ) -> list[PipelineResult]:
         """Execute an adapter for the supplied source synchronously."""

         return asyncio.run(self.run_async(source, params=params, resume=resume))

     async def run_async(
         self,
         source: str,
         *,
         params: Iterable[dict[str, Any]] | None = None,
         resume: bool = False,
     ) -> list[PipelineResult]:
         """Execute an adapter within an existing asyncio event loop."""

-        client = self._client_factory()
-        adapter = self._resolve_adapter(source, client)
-        outputs: list[PipelineResult] = []
-        try:
+        async with AsyncExitStack() as stack:
+            raw_client = self._client_factory()
+            client = await _enter_client(stack, raw_client)
+            adapter = self._resolve_adapter(source, client)
+            outputs: list[PipelineResult] = []
             if params is None:
                 results = await self._invoke(adapter, {}, resume=resume)
                 outputs.append(PipelineResult(source=source, doc_ids=results))
             else:
                 for entry in params:
                     results = await self._invoke(adapter, entry, resume=resume)
                     outputs.append(PipelineResult(source=source, doc_ids=results))
-        finally:
-            await client.aclose()
-        return outputs
+            return outputs

     def status(self) -> dict[str, list[dict[str, Any]]]:
         summary: dict[str, list[dict[str, Any]]] = {}
         for entry in self.ledger.entries():
             summary.setdefault(entry.state, []).append(
                 {"doc_id": entry.doc_id, "metadata": dict(entry.metadata)}
             )
         return summary

     async def _invoke(
         self,
         adapter: BaseAdapter[Any],
         params: dict[str, Any],
         *,
         resume: bool,
     ) -> list[str]:
         invocation_params = dict(params)
         invocation_params["resume"] = resume
         results = list(await adapter.run(**invocation_params))
         return [result.document.doc_id for result in results]

     def _resolve_adapter(self, source: str, client: AsyncHttpClient) -> BaseAdapter[Any]:
         return self._registry.get_adapter(source, AdapterContext(ledger=self.ledger), client)

+
+async def _enter_client(stack: AsyncExitStack, client: AsyncHttpClient | Any) -> AsyncHttpClient | Any:
+    """Ensure both context-manager and legacy clients close correctly."""
+
+    if hasattr(client, "__aenter__") and hasattr(client, "__aexit__"):
+        return await stack.enter_async_context(client)
+
+    stack.push_async_callback(client.aclose)
+    return client
+
 __all__ = [
     "IngestionPipeline",
     "PipelineResult",
 ]
diff --git a/tests/conftest.py b/tests/conftest.py
index f66dd762b21c38508dd60dfcf118bd26fab72b03..4e64f7d420063fd0a6e8680a639d11241ac8c6ca 100644
--- a/tests/conftest.py
+++ b/tests/conftest.py
@@ -1,48 +1,50 @@
 from __future__ import annotations

 import ast
 import asyncio
 import os
 import shutil
 import sys
 import threading
 import types
 from collections import defaultdict
 from dataclasses import dataclass, field
 from datetime import datetime, timezone
 from pathlib import Path
+from trace import Trace
 from typing import Any, Callable, Iterable, Iterator, Mapping, MutableMapping, Sequence, cast

 ROOT = Path(__file__).resolve().parents[1]
 SRC = ROOT / "src"
 PACKAGE_ROOT = SRC / "Medical_KG"
 TARGET_COVERAGE = float(os.environ.get("COVERAGE_TARGET", "0.95"))

 if str(SRC) not in sys.path:
     sys.path.insert(0, str(SRC))

+
 try:  # prefer real FastAPI when available
     import fastapi  # noqa: F401  # pragma: no cover - import only
 except ImportError:  # pragma: no cover - fallback for environments without fastapi
     fastapi_module = types.ModuleType("fastapi")

     class _FastAPI:
         def __init__(self, *args: Any, **kwargs: Any) -> None:
             self.args = args
             self.kwargs = kwargs

     class _APIRouter:
         def __init__(self, *args: Any, **kwargs: Any) -> None:
             self.args = args
             self.kwargs = kwargs
             self.routes: list[tuple[str, Callable[..., Any]]] = []

         def post(
             self, path: str, **_options: Any
         ) -> Callable[[Callable[..., Any]], Callable[..., Any]]:
             def _decorator(func: Callable[..., Any]) -> Callable[..., Any]:
                 self.routes.append((path, func))
                 return func

             return _decorator

@@ -187,62 +189,63 @@ if "httpx" not in sys.modules:
                 return await self.request("POST", url, json=json, headers=headers)

             def stream(self, method: str, url: str, **kwargs: Any) -> _StreamContext:
                 if self._transport is None:
                     raise RuntimeError("Mock transport required in tests")
                 return _StreamContext(self._transport, method, url, kwargs)

             async def aclose(self) -> None:
                 return None

             async def __aenter__(self) -> "AsyncClient":
                 return self

             async def __aexit__(self, *_exc: Any) -> None:
                 return None

         httpx_module.AsyncClient = AsyncClient
         httpx_module.MockTransport = MockTransport
         httpx_module.TimeoutException = TimeoutException
         httpx_module.HTTPError = HTTPError
         httpx_module.Response = Response
         httpx_module.Request = Request

         sys.modules["httpx"] = httpx_module

-from trace import Trace

-import pytest
+import pytest  # noqa: E402

-from Medical_KG.ingestion.ledger import LedgerEntry
-from Medical_KG.retrieval.models import (
+from Medical_KG.ingestion.ledger import LedgerEntry  # noqa: E402
+from Medical_KG.ingestion.models import Document  # noqa: E402
+from Medical_KG.retrieval.models import (  # noqa: E402
     RetrievalRequest,
     RetrievalResponse,
     RetrievalResult,
     RetrieverScores,
 )
-from Medical_KG.retrieval.types import JSONValue, SearchHit, VectorHit
+from Medical_KG.retrieval.types import JSONValue, SearchHit, VectorHit  # noqa: E402
+from Medical_KG.utils.optional_dependencies import get_httpx_module  # noqa: E402


 @pytest.fixture
 def monkeypatch_fixture(monkeypatch: pytest.MonkeyPatch) -> pytest.MonkeyPatch:
     return monkeypatch


 _TRACE = Trace(count=True, trace=False)


 def _activate_tracing() -> None:  # pragma: no cover - instrumentation only
     trace_func = cast(Any, _TRACE.globaltrace)
     if trace_func is None:
         return
     sys.settrace(trace_func)
     threading.settrace(trace_func)


 if os.environ.get("DISABLE_COVERAGE_TRACE") != "1":
     _activate_tracing()


 @pytest.fixture(scope="session", autouse=True)
 def cleanup_test_artifacts() -> Iterator[None]:
     """Remove coverage and hypothesis artifacts after the test session."""
@@ -289,52 +292,50 @@ def pytest_sessionfinish(

     missing: dict[Path, set[int]] = {}
     per_file_coverage: list[tuple[Path, float]] = []
     total_statements = 0
     total_covered = 0

     for py_file in PACKAGE_ROOT.rglob("*.py"):
         statements = _statement_lines(py_file)
         if not statements:
             continue
         executed_lines = executed.get(py_file.resolve(), set())
         covered = statements & executed_lines
         uncovered = statements - covered
         rel_path = py_file.relative_to(ROOT)
         per_file_coverage.append(
             (
                 rel_path,
                 len(covered) / len(statements) if statements else 1.0,
             )
         )
         total_statements += len(statements)
         total_covered += len(covered)
         if uncovered:
             missing[rel_path] = uncovered

-    overall = total_covered / total_statements if total_statements else 1.0
-
     report_items = {path: lines for path, lines in missing.items() if "ingestion" in str(path)}

     if report_items:
         details = "; ".join(
             f"{path}:{','.join(str(line) for line in sorted(lines))}"
             for path, lines in sorted(report_items.items())
         )
         (ROOT / "coverage_missing.txt").write_text(details, encoding="utf-8")
     else:
         coverage_file = ROOT / "coverage_missing.txt"
         if coverage_file.exists():
             coverage_file.unlink()

     ingestion_root = (SRC / "Medical_KG" / "ingestion").resolve()
     adapter_root = ingestion_root / "adapters"
     ingestion_missing = {
         path: lines
         for path, lines in missing.items()
         if adapter_root in (path.resolve().parents) and path.resolve() in executed
     }
     if os.environ.get("SKIP_INGESTION_COVERAGE") == "1":
         ingestion_missing = {}

     enforce_coverage = os.environ.get("ENFORCE_INGESTION_COVERAGE") == "1"

@@ -695,28 +696,25 @@ def retrieval_request() -> RetrievalRequest:
     return RetrievalRequest(query="pembrolizumab", top_k=3)


 @pytest.fixture
 def expected_retrieval_response() -> RetrievalResponse:
     result = RetrievalResult(
         chunk_id="chunk-bm25-1",
         doc_id="doc-1",
         text="What is pembrolizumab",
         title_path=None,
         section=None,
         score=2.4,
         scores=RetrieverScores(bm25=2.4),
         metadata={"granularity": "chunk"},
     )
     return RetrievalResponse(
         results=[result],
         timings=[],
         expanded_terms={"pembrolizumab": 1.0},
         intent="general",
         latency_ms=1.0,
         from_=0,
         size=1,
         metadata={"feature_flags": {"rerank_enabled": False}},
     )
-
-
-from Medical_KG.utils.optional_dependencies import get_httpx_module
diff --git a/tests/ingestion/test_adapters.py b/tests/ingestion/test_adapters.py
index 025696cd7b2065385f8c5be2c14adca3ed06e5bc..3d26290f339227dd0d009b7265d962d3d237d8d8 100644
--- a/tests/ingestion/test_adapters.py
+++ b/tests/ingestion/test_adapters.py
@@ -1,31 +1,31 @@
 from __future__ import annotations

 import asyncio
 from collections.abc import AsyncIterator
 from types import SimpleNamespace
-from typing import Any, Mapping, MutableMapping, cast
+from typing import Any, Callable, Mapping, MutableMapping, cast

 import pytest

 from Medical_KG.ingestion.adapters.base import AdapterContext, BaseAdapter
 from Medical_KG.ingestion.adapters.clinical import (
     AccessGudidAdapter,
     ClinicalTrialsGovAdapter,
     DailyMedAdapter,
     OpenFdaAdapter,
     OpenFdaUdiAdapter,
     RxNormAdapter,
     UdiValidator,
 )
 from Medical_KG.ingestion.adapters.guidelines import (
     CdcSocrataAdapter,
     CdcWonderAdapter,
     NiceGuidelineAdapter,
     OpenPrescribingAdapter,
     UspstfAdapter,
     WhoGhoAdapter,
 )
 from Medical_KG.ingestion.adapters.literature import (
     LiteratureFallback,
     LiteratureFallbackError,
     MedRxivAdapter,
@@ -83,563 +83,570 @@ from tests.ingestion.fixtures.terminology import (
     mesh_descriptor,
     rxnav_properties,
     snomed_record,
     umls_record,
 )


 def _run(coro: Any) -> Any:
     loop = asyncio.new_event_loop()
     try:
         return loop.run_until_complete(coro)
     finally:
         loop.close()


 def _stub_http_client() -> AsyncHttpClient:
     class _Stub:
         def set_rate_limit(self, *_: object, **__: object) -> None:
             return None

     return cast(AsyncHttpClient, _Stub())


 def test_pubmed_adapter_parses_fixture(fake_ledger: Any, monkeypatch: pytest.MonkeyPatch) -> None:
     async def _test() -> None:
-        client = AsyncHttpClient()
-        adapter = PubMedAdapter(AdapterContext(fake_ledger), client)
+        async with AsyncHttpClient() as client:
+            adapter = PubMedAdapter(AdapterContext(fake_ledger), client)

-        search_payload = pubmed_search_payload()
-        summary_payload = pubmed_summary_payload()
-        fetch_payload = pubmed_fetch_xml()
+            search_payload = pubmed_search_payload()
+            summary_payload = pubmed_summary_payload()
+            fetch_payload = pubmed_fetch_xml()

-        async def fake_fetch_json(url: str, **_: Any) -> dict[str, Any]:
-            return search_payload if "esearch" in url else summary_payload
+            async def fake_fetch_json(url: str, **_: Any) -> dict[str, Any]:
+                return search_payload if "esearch" in url else summary_payload

-        async def fake_fetch_text(url: str, **_: Any) -> str:
-            assert "efetch" in url
-            return fetch_payload
+            async def fake_fetch_text(url: str, **_: Any) -> str:
+                assert "efetch" in url
+                return fetch_payload

-        monkeypatch.setattr(adapter, "fetch_json", fake_fetch_json)
-        monkeypatch.setattr(adapter, "fetch_text", fake_fetch_text)
+            monkeypatch.setattr(adapter, "fetch_json", fake_fetch_json)
+            monkeypatch.setattr(adapter, "fetch_text", fake_fetch_text)

-        results = await adapter.run(term="sepsis", retmax=10)
-        assert len(results) == 1
-        document = results[0].document
-        assert document.metadata["pmid"] == "12345678"
-        assert isinstance(document.raw, dict)
-        assert "mesh_terms" in document.raw
-        await client.aclose()
+            results = await adapter.run(term="sepsis", retmax=10)
+            assert len(results) == 1
+            document = results[0].document
+            assert document.metadata["pmid"] == "12345678"
+            assert isinstance(document.raw, dict)
+            assert "mesh_terms" in document.raw

     _run(_test())


 def test_pubmed_adapter_handles_missing_history(
     fake_ledger: Any, monkeypatch: pytest.MonkeyPatch
 ) -> None:
     async def _test() -> None:
-        client = AsyncHttpClient()
-        adapter = PubMedAdapter(AdapterContext(fake_ledger), client)
+        async with AsyncHttpClient() as client:
+            adapter = PubMedAdapter(AdapterContext(fake_ledger), client)

-        search_payload = pubmed_search_without_history()
-        summary_payload = pubmed_summary_payload()
-        fetch_payload = pubmed_fetch_xml()
+            search_payload = pubmed_search_without_history()
+            summary_payload = pubmed_summary_payload()
+            fetch_payload = pubmed_fetch_xml()

-        async def fake_fetch_json(url: str, **_: Any) -> dict[str, Any]:
-            return search_payload if "esearch" in url else summary_payload
+            async def fake_fetch_json(url: str, **_: Any) -> dict[str, Any]:
+                return search_payload if "esearch" in url else summary_payload

-        async def fake_fetch_text(url: str, **_: Any) -> str:
-            return fetch_payload
+            async def fake_fetch_text(url: str, **_: Any) -> str:
+                return fetch_payload

-        monkeypatch.setattr(adapter, "fetch_json", fake_fetch_json)
-        monkeypatch.setattr(adapter, "fetch_text", fake_fetch_text)
+            monkeypatch.setattr(adapter, "fetch_json", fake_fetch_json)
+            monkeypatch.setattr(adapter, "fetch_text", fake_fetch_text)

-        results = await adapter.run(term="oncology")
-        assert results
-        await client.aclose()
+            results = await adapter.run(term="oncology")
+            assert results

     _run(_test())


 def test_pubmed_rate_limit_adjusts_for_api_key(fake_ledger: Any) -> None:
-    client_without_key = AsyncHttpClient()
-    adapter_without_key = PubMedAdapter(AdapterContext(fake_ledger), client_without_key)
-    client_with_key = AsyncHttpClient()
-    adapter_with_key = PubMedAdapter(AdapterContext(fake_ledger), client_with_key, api_key="token")
-    host = "eutils.ncbi.nlm.nih.gov"
-    assert adapter_without_key.client._limits[host].rate == 3
-    assert adapter_with_key.client._limits[host].rate == 10
-    _run(client_without_key.aclose())
-    _run(client_with_key.aclose())
+    async def _inspect() -> tuple[int, int]:
+        host = "eutils.ncbi.nlm.nih.gov"
+        async with AsyncHttpClient() as client_without_key:
+            adapter_without_key = PubMedAdapter(AdapterContext(fake_ledger), client_without_key)
+            without_rate = adapter_without_key.client._limits[host].rate
+        async with AsyncHttpClient() as client_with_key:
+            adapter_with_key = PubMedAdapter(
+                AdapterContext(fake_ledger), client_with_key, api_key="token"
+            )
+            with_rate = adapter_with_key.client._limits[host].rate
+        return without_rate, with_rate
+
+    without_rate, with_rate = _run(_inspect())
+    assert without_rate == 3
+    assert with_rate == 10


 def test_pubmed_validate_rejects_non_pubmed_payload(fake_ledger: Any) -> None:
-    client = AsyncHttpClient()
-    adapter = PubMedAdapter(AdapterContext(fake_ledger), client)
-    document = Document(
-        doc_id="doc-1",
-        source="pubmed",
-        content="",
-        metadata={},
-        raw={
-            "code": "123456",
-            "display": "Hypertension",
-            "designation": [{"value": "Hypertension"}],
-        },
-    )
-    with pytest.raises(ValueError):
-        adapter.validate(document)
-    _run(client.aclose())
+    async def _test() -> None:
+        async with AsyncHttpClient() as client:
+            adapter = PubMedAdapter(AdapterContext(fake_ledger), client)
+            document = Document(
+                doc_id="doc-1",
+                source="pubmed",
+                content="",
+                metadata={},
+                raw={
+                    "code": "123456",
+                    "display": "Hypertension",
+                    "designation": [{"value": "Hypertension"}],
+                },
+            )
+            with pytest.raises(ValueError):
+                adapter.validate(document)
+
+    _run(_test())


 def test_clinical_trials_parses_metadata(fake_ledger: Any) -> None:
     async def _test() -> None:
-        client = AsyncHttpClient()
-        adapter = ClinicalTrialsGovAdapter(
-            AdapterContext(fake_ledger), client, bootstrap_records=[clinical_study()]
-        )
-        results = await adapter.run()
-        document = results[0].document
-        assert document.metadata["record_version"] == "2024-01-01"
-        assert document.raw["phase"]
-        assert isinstance(document.raw, dict)
-        assert isinstance(document.raw["arms"], list)
-        assert isinstance(document.raw.get("outcomes"), list)
-        assert isinstance(document.raw["eligibility"], str)
-        await client.aclose()
+        async with AsyncHttpClient() as client:
+            adapter = ClinicalTrialsGovAdapter(
+                AdapterContext(fake_ledger), client, bootstrap_records=[clinical_study()]
+            )
+            results = await adapter.run()
+            document = results[0].document
+            assert document.metadata["record_version"] == "2024-01-01"
+            assert document.raw["phase"]
+            assert isinstance(document.raw, dict)
+            assert isinstance(document.raw["arms"], list)
+            assert isinstance(document.raw.get("outcomes"), list)
+            assert isinstance(document.raw["eligibility"], str)

     _run(_test())


 def test_clinical_trials_handles_partial_payload(fake_ledger: Any) -> None:
     async def _test() -> None:
-        client = AsyncHttpClient()
-        adapter = ClinicalTrialsGovAdapter(
-            AdapterContext(fake_ledger),
-            client,
-            bootstrap_records=[clinical_study_without_outcomes()],
-        )
-        results = await adapter.run()
-        payload = results[0].document.raw
-        assert isinstance(payload, dict)
-        assert payload.get("outcomes") is None
-        assert isinstance(payload["arms"], list)
-        await client.aclose()
+        async with AsyncHttpClient() as client:
+            adapter = ClinicalTrialsGovAdapter(
+                AdapterContext(fake_ledger),
+                client,
+                bootstrap_records=[clinical_study_without_outcomes()],
+            )
+            results = await adapter.run()
+            payload = results[0].document.raw
+            assert isinstance(payload, dict)
+            assert payload.get("outcomes") is None
+            assert isinstance(payload["arms"], list)

     _run(_test())


 def test_clinical_trials_validate_rejects_invalid(fake_ledger: Any) -> None:
-    client = AsyncHttpClient()
-    adapter = ClinicalTrialsGovAdapter(AdapterContext(fake_ledger), client)
-    document = adapter.parse(clinical_study())
-    document.raw["nct_id"] = "BAD"
-    with pytest.raises(ValueError):
-        adapter.validate(document)
-    _run(client.aclose())
+    async def _test() -> None:
+        async with AsyncHttpClient() as client:
+            adapter = ClinicalTrialsGovAdapter(AdapterContext(fake_ledger), client)
+            document = adapter.parse(clinical_study())
+            document.raw["nct_id"] = "BAD"
+            with pytest.raises(ValueError):
+                adapter.validate(document)
+
+    _run(_test())


 def test_clinical_trials_paginates(fake_ledger: Any, monkeypatch: pytest.MonkeyPatch) -> None:
     async def _test() -> None:
-        client = AsyncHttpClient()
-        adapter = ClinicalTrialsGovAdapter(AdapterContext(fake_ledger), client)
-        calls: list[MutableMapping[str, Any]] = []
-
-        async def fake_fetch_json(
-            url: str, *, params: MutableMapping[str, Any] | None = None, **_: Any
-        ) -> dict[str, Any]:
-            assert params is not None
-            calls.append(dict(params))
-            if "pageToken" in params:
+        async with AsyncHttpClient() as client:
+            adapter = ClinicalTrialsGovAdapter(AdapterContext(fake_ledger), client)
+            calls: list[MutableMapping[str, Any]] = []
+
+            async def fake_fetch_json(
+                url: str, *, params: MutableMapping[str, Any] | None = None, **_: Any
+            ) -> dict[str, Any]:
+                assert params is not None
+                calls.append(dict(params))
+                if "pageToken" in params:
+                    return {
+                        "studies": [
+                            {"protocolSection": {"identificationModule": {"nctId": "NCT2"}}}
+                        ]
+                    }
                 return {
-                    "studies": [{"protocolSection": {"identificationModule": {"nctId": "NCT2"}}}]
+                    "studies": [
+                        {"protocolSection": {"identificationModule": {"nctId": "NCT1"}}}
+                    ],
+                    "nextPageToken": "token",
                 }
-            return {
-                "studies": [{"protocolSection": {"identificationModule": {"nctId": "NCT1"}}}],
-                "nextPageToken": "token",
-            }

-        monkeypatch.setattr(adapter, "fetch_json", fake_fetch_json)
-        collected: list[str] = []
-        async for record in adapter.fetch():
-            nct = record["protocolSection"]["identificationModule"]["nctId"]
-            collected.append(nct)
+            monkeypatch.setattr(adapter, "fetch_json", fake_fetch_json)
+            collected: list[str] = []
+            async for record in adapter.fetch():
+                nct = record["protocolSection"]["identificationModule"]["nctId"]
+                collected.append(nct)

-        assert collected == ["NCT1", "NCT2"]
-        assert len(calls) == 2
-        await client.aclose()
+            assert collected == ["NCT1", "NCT2"]
+            assert len(calls) == 2

     _run(_test())


 @pytest.mark.parametrize("status", [404, 500])
 def test_clinical_trials_propagates_http_errors(
     fake_ledger: Any, httpx_mock_transport: Any, status: int
 ) -> None:
     HTTPX = get_httpx_module()

     def handler(request: Any) -> Any:
         response = HTTPX.Response(status_code=status, request=request, text="error")
         return response

     httpx_mock_transport(handler)
-    client = AsyncHttpClient()
-    adapter = ClinicalTrialsGovAdapter(AdapterContext(fake_ledger), client)
-    with pytest.raises(HTTPX.HTTPStatusError):
-        _run(adapter.run())
-    _run(client.aclose())
+    async def _test() -> None:
+        async with AsyncHttpClient() as client:
+            adapter = ClinicalTrialsGovAdapter(AdapterContext(fake_ledger), client)
+            with pytest.raises(HTTPX.HTTPStatusError):
+                await adapter.run()
+
+    _run(_test())


 def test_clinical_trials_retries_on_rate_limit(
     fake_ledger: Any, httpx_mock_transport: Any, monkeypatch: pytest.MonkeyPatch
 ) -> None:
     HTTPX = get_httpx_module()
     calls: list[str] = []

     studies_payload = {"studies": [clinical_study()]}

     def handler(request: Any) -> Any:
         calls.append(str(request.url))
         if len(calls) == 1:
             return HTTPX.Response(
                 status_code=429,
                 headers={"Retry-After": "0"},
                 request=request,
                 text="rate limited",
             )
         return HTTPX.Response(status_code=200, json=studies_payload, request=request)

     httpx_mock_transport(handler)

     async def _sleep(_: float) -> None:
         return None

     monkeypatch.setattr("Medical_KG.ingestion.http_client.asyncio.sleep", _sleep)

-    client = AsyncHttpClient()
-    adapter = ClinicalTrialsGovAdapter(AdapterContext(fake_ledger), client)
-    results = _run(adapter.run())
-    assert len(results) == 1
-    assert len(calls) == 2
-    _run(client.aclose())
+    async def _test() -> None:
+        async with AsyncHttpClient() as client:
+            adapter = ClinicalTrialsGovAdapter(AdapterContext(fake_ledger), client)
+            results = await adapter.run()
+            assert len(results) == 1
+            assert len(calls) == 2
+
+    _run(_test())


 def test_clinical_trials_metadata_enrichment(fake_ledger: Any) -> None:
     record = clinical_study()
     protocol = record.setdefault("protocolSection", {})
     protocol.setdefault("sponsorCollaboratorsModule", {})["leadSponsor"] = {
         "name": "Example Sponsor"
     }
     protocol.setdefault("designModule", {}).setdefault("enrollmentInfo", {})["count"] = 256
     status_module = protocol.setdefault("statusModule", {})
     status_module["startDateStruct"] = {"date": "2024-05-01"}
     status_module["completionDateStruct"] = {"date": "2025-10-31"}

-    client = AsyncHttpClient()
-    adapter = ClinicalTrialsGovAdapter(
-        AdapterContext(fake_ledger), client, bootstrap_records=[record]
-    )
-    results = _run(adapter.run())
-    metadata = results[0].document.metadata
-    assert metadata["sponsor"] == "Example Sponsor"
-    assert metadata["enrollment"] == 256
-    assert metadata["start_date"] == "2024-05-01"
-    assert metadata["completion_date"] == "2025-10-31"
-    _run(client.aclose())
+    async def _test() -> None:
+        async with AsyncHttpClient() as client:
+            adapter = ClinicalTrialsGovAdapter(
+                AdapterContext(fake_ledger), client, bootstrap_records=[record]
+            )
+            results = await adapter.run()
+            metadata = results[0].document.metadata
+            assert metadata["sponsor"] == "Example Sponsor"
+            assert metadata["enrollment"] == 256
+            assert metadata["start_date"] == "2024-05-01"
+            assert metadata["completion_date"] == "2025-10-31"
+
+    _run(_test())


 def test_openfda_requires_identifier(fake_ledger: Any) -> None:
     async def _test() -> None:
-        client = AsyncHttpClient()
-        adapter = OpenFdaAdapter(
-            AdapterContext(fake_ledger), client, bootstrap_records=[{"foo": "bar"}]
-        )
-        with pytest.raises(ValueError):
-            await adapter.run(resource="drug/event")
-        await client.aclose()
+        async with AsyncHttpClient() as client:
+            adapter = OpenFdaAdapter(
+                AdapterContext(fake_ledger), client, bootstrap_records=[{"foo": "bar"}]
+            )
+            with pytest.raises(ValueError):
+                await adapter.run(resource="drug/event")

     _run(_test())


 def test_openfda_parses_identifier(fake_ledger: Any) -> None:
     async def _test() -> None:
-        client = AsyncHttpClient()
-        adapter = OpenFdaAdapter(
-            AdapterContext(fake_ledger), client, bootstrap_records=[openfda_faers_record()]
-        )
-        results = await adapter.run(resource="drug/event")
-        assert results[0].document.metadata["identifier"]
-        assert isinstance(results[0].document.raw["record"], dict)
-        await client.aclose()
+        async with AsyncHttpClient() as client:
+            adapter = OpenFdaAdapter(
+                AdapterContext(fake_ledger), client, bootstrap_records=[openfda_faers_record()]
+            )
+            results = await adapter.run(resource="drug/event")
+            assert results[0].document.metadata["identifier"]
+            assert isinstance(results[0].document.raw["record"], dict)

     _run(_test())


 def test_openfda_udi_enriches_metadata(fake_ledger: Any) -> None:
     async def _test() -> None:
-        client = AsyncHttpClient()
-        adapter = OpenFdaUdiAdapter(
-            AdapterContext(fake_ledger), client, bootstrap_records=[openfda_udi_record()]
-        )
-        results = await adapter.run(resource="device/udi")
-        metadata = results[0].document.metadata
-        assert metadata["identifier"]
-        assert metadata["udi_di"].isdigit()
-        assert isinstance(results[0].document.raw["record"], dict)
-        await client.aclose()
+        async with AsyncHttpClient() as client:
+            adapter = OpenFdaUdiAdapter(
+                AdapterContext(fake_ledger), client, bootstrap_records=[openfda_udi_record()]
+            )
+            results = await adapter.run(resource="device/udi")
+            metadata = results[0].document.metadata
+            assert metadata["identifier"]
+            assert metadata["udi_di"].isdigit()
+            assert isinstance(results[0].document.raw["record"], dict)

     _run(_test())


 def test_accessgudid_validation(fake_ledger: Any) -> None:
     async def _test() -> None:
         payload = accessgudid_record()
-        client = AsyncHttpClient()
-        adapter = AccessGudidAdapter(
-            AdapterContext(fake_ledger), client, bootstrap_records=[payload]
-        )
-        results = await adapter.run(udi_di="00380740000011")
-        assert results[0].document.metadata["udi_di"] == "00380740000011"
-        await client.aclose()
+        async with AsyncHttpClient() as client:
+            adapter = AccessGudidAdapter(
+                AdapterContext(fake_ledger), client, bootstrap_records=[payload]
+            )
+            results = await adapter.run(udi_di="00380740000011")
+            assert results[0].document.metadata["udi_di"] == "00380740000011"

     _run(_test())


 def test_accessgudid_rejects_bad_udi(fake_ledger: Any) -> None:
     async def _test() -> None:
         payload = accessgudid_record()
         payload["udi"]["deviceIdentifier"] = "1234"
-        client = AsyncHttpClient()
-        adapter = AccessGudidAdapter(
-            AdapterContext(fake_ledger), client, bootstrap_records=[payload]
-        )
-        with pytest.raises(ValueError):
-            await adapter.run(udi_di="1234")
-        await client.aclose()
+        async with AsyncHttpClient() as client:
+            adapter = AccessGudidAdapter(
+                AdapterContext(fake_ledger), client, bootstrap_records=[payload]
+            )
+            with pytest.raises(ValueError):
+                await adapter.run(udi_di="1234")

     _run(_test())


 def test_dailymed_parses_sections(fake_ledger: Any) -> None:
     async def _test() -> None:
-        client = AsyncHttpClient()
-        adapter = DailyMedAdapter(
-            AdapterContext(fake_ledger), client, bootstrap_records=[dailymed_xml()]
-        )
-        results = await adapter.run(setid="setid")
-        sections = results[0].document.raw["sections"]
-        assert sections and sections[0]["text"]
-        await client.aclose()
+        async with AsyncHttpClient() as client:
+            adapter = DailyMedAdapter(
+                AdapterContext(fake_ledger), client, bootstrap_records=[dailymed_xml()]
+            )
+            results = await adapter.run(setid="setid")
+            sections = results[0].document.raw["sections"]
+            assert sections and sections[0]["text"]

     _run(_test())


 def test_pmc_adapter_collects_tables(fake_ledger: Any, monkeypatch: pytest.MonkeyPatch) -> None:
     async def _test() -> None:
-        client = AsyncHttpClient()
-        adapter = PmcAdapter(AdapterContext(fake_ledger), client)
+        async with AsyncHttpClient() as client:
+            adapter = PmcAdapter(AdapterContext(fake_ledger), client)

-        async def fake_fetch_text(*_: Any, **__: Any) -> str:
-            return f"<OAI>{pmc_record_xml()}</OAI>"
+            async def fake_fetch_text(*_: Any, **__: Any) -> str:
+                return f"<OAI>{pmc_record_xml()}</OAI>"

-        monkeypatch.setattr(adapter, "fetch_text", fake_fetch_text)
-        results = await adapter.run(set_spec="pmc")
-        document = results[0].document
-        assert document.metadata["pmcid"] == "PMC1234567"
-        assert document.metadata["datestamp"] == "2024-01-15"
-        assert "Sepsis" in document.content
-        assert isinstance(document.raw, dict)
-        await client.aclose()
+            monkeypatch.setattr(adapter, "fetch_text", fake_fetch_text)
+            results = await adapter.run(set_spec="pmc")
+            document = results[0].document
+            assert document.metadata["pmcid"] == "PMC1234567"
+            assert document.metadata["datestamp"] == "2024-01-15"
+            assert "Sepsis" in document.content
+            assert isinstance(document.raw, dict)

     _run(_test())


 def test_pmc_adapter_extracts_sections_and_references(
     fake_ledger: Any, monkeypatch: pytest.MonkeyPatch
 ) -> None:
     async def _test() -> None:
-        client = AsyncHttpClient()
-        adapter = PmcAdapter(AdapterContext(fake_ledger), client)
+        async with AsyncHttpClient() as client:
+            adapter = PmcAdapter(AdapterContext(fake_ledger), client)
         xml_payload = """
         <record>
           <header>
             <identifier>oai:pubmedcentral.nih.gov:PMC999999</identifier>
             <datestamp>2024-02-02</datestamp>
           </header>
           <metadata>
             <article>
               <front>
                 <article-title>Fallback Study</article-title>
               </front>
               <body>
                 <sec>
                   <title>Introduction</title>
                   <p>Sepsis overview</p>
                 </sec>
                 <table-wrap>
                   <label>Table 1</label>
                   <caption><p>Data summary</p></caption>
                 </table-wrap>
               </body>
               <back>
                 <ref-list>
                   <ref>
                     <label>1</label>
                     <mixed-citation>Example reference</mixed-citation>
                   </ref>
                 </ref-list>
               </back>
             </article>
           </metadata>
         </record>
         """

         async def fake_fetch_text(*_: object, **__: object) -> str:
             return f"<OAI>{xml_payload}</OAI>"

-        monkeypatch.setattr(adapter, "fetch_text", fake_fetch_text)
-        results = await adapter.run(set_spec="pmc")
-        payload = results[0].document.raw
-        assert isinstance(payload, dict)
-        assert payload["sections"]
-        assert payload["references"]
-        assert payload["tables"]
-        await client.aclose()
+            monkeypatch.setattr(adapter, "fetch_text", fake_fetch_text)
+            results = await adapter.run(set_spec="pmc")
+            payload = results[0].document.raw
+            assert isinstance(payload, dict)
+            assert payload["sections"]
+            assert payload["references"]
+            assert payload["tables"]

     _run(_test())


 def test_medrxiv_paginates(fake_ledger: Any, monkeypatch: pytest.MonkeyPatch) -> None:
     async def _test() -> None:
-        client = AsyncHttpClient()
-        adapter = MedRxivAdapter(AdapterContext(fake_ledger), client)
+        async with AsyncHttpClient() as client:
+            adapter = MedRxivAdapter(AdapterContext(fake_ledger), client)

-        async def fake_fetch_json(*_: Any, **__: Any) -> dict[str, Any]:
-            if not getattr(fake_fetch_json, "called", False):
-                fake_fetch_json.called = True  # type: ignore[attr-defined]
-                return {"results": [medrxiv_record()], "next_cursor": "next"}
-            return {"results": [medrxiv_record()], "next_cursor": None}
+            async def fake_fetch_json(*_: Any, **__: Any) -> dict[str, Any]:
+                if not getattr(fake_fetch_json, "called", False):
+                    fake_fetch_json.called = True  # type: ignore[attr-defined]
+                    return {"results": [medrxiv_record()], "next_cursor": "next"}
+                return {"results": [medrxiv_record()], "next_cursor": None}

-        fake_fetch_json.called = False  # type: ignore[attr-defined]
-        monkeypatch.setattr(adapter, "fetch_json", fake_fetch_json)
+            fake_fetch_json.called = False  # type: ignore[attr-defined]
+            monkeypatch.setattr(adapter, "fetch_json", fake_fetch_json)

-        results = await adapter.run()
-        assert len(results) == 2
-        await client.aclose()
+            results = await adapter.run()
+            assert len(results) == 2

     _run(_test())


 def test_guideline_adapters(fake_ledger: Any) -> None:
     async def _test() -> None:
-        client = AsyncHttpClient()
-        nice = NiceGuidelineAdapter(
-            AdapterContext(fake_ledger), client, bootstrap_records=[nice_guideline()]
-        )
-        cdc = CdcSocrataAdapter(
-            AdapterContext(fake_ledger), client, bootstrap_records=cdc_socrata_record()
-        )
-        nic_results = await nice.run()
-        cdc_results = await cdc.run(dataset="abc")
-        assert nic_results[0].document.metadata["uid"].startswith("CG")
-        assert isinstance(nic_results[0].document.raw, dict)
-        assert isinstance(nic_results[0].document.raw["summary"], str)
-        assert nic_results[0].document.raw["url"] is None or isinstance(
-            nic_results[0].document.raw["url"], str
-        )
-        assert cdc_results[0].document.metadata["identifier"].startswith("CA-")
-        assert isinstance(cdc_results[0].document.raw["record"], dict)
-        await client.aclose()
+        async with AsyncHttpClient() as client:
+            nice = NiceGuidelineAdapter(
+                AdapterContext(fake_ledger), client, bootstrap_records=[nice_guideline()]
+            )
+            cdc = CdcSocrataAdapter(
+                AdapterContext(fake_ledger), client, bootstrap_records=cdc_socrata_record()
+            )
+            nic_results = await nice.run()
+            cdc_results = await cdc.run(dataset="abc")
+            assert nic_results[0].document.metadata["uid"].startswith("CG")
+            assert isinstance(nic_results[0].document.raw, dict)
+            assert isinstance(nic_results[0].document.raw["summary"], str)
+            assert nic_results[0].document.raw["url"] is None or isinstance(
+                nic_results[0].document.raw["url"], str
+            )
+            assert cdc_results[0].document.metadata["identifier"].startswith("CA-")
+            assert isinstance(cdc_results[0].document.raw["record"], dict)

     _run(_test())


 def test_terminology_adapters_parse(fake_ledger: Any) -> None:
     async def _test() -> None:
-        client = AsyncHttpClient()
-        context = AdapterContext(fake_ledger)
-        mesh = MeSHAdapter(context, client, bootstrap_records=[mesh_descriptor()])
-        umls = UMLSAdapter(context, client, bootstrap_records=[umls_record()])
-        loinc = LoincAdapter(context, client, bootstrap_records=[loinc_record()])
-        icd = Icd11Adapter(context, client, bootstrap_records=[icd11_record()])
-        snomed = SnomedAdapter(context, client, bootstrap_records=[snomed_record()])
-        rxnorm = RxNormAdapter(context, client, bootstrap_records=[rxnav_properties()])
-
-        results = await asyncio.gather(
-            mesh.run(descriptor_id="D012345"),
-            umls.run(cui="C1234567"),
-            loinc.run(code="4548-4"),
-            icd.run(code="1A00"),
-            snomed.run(code="44054006"),
-            rxnorm.run(rxcui="12345"),
-        )
-
-        assert results[0][0].document.metadata["descriptor_id"].startswith("D")
-        assert isinstance(results[0][0].document.raw, dict)
-        assert results[1][0].document.metadata["cui"].startswith("C")
-        assert isinstance(results[1][0].document.raw, dict)
-        assert results[2][0].document.metadata["code"].endswith("-4")
-        assert isinstance(results[2][0].document.raw, dict)
-        assert results[5][0].document.metadata["rxcui"].isdigit()
-        assert isinstance(results[3][0].document.raw["title"], str)
-        assert isinstance(results[4][0].document.raw["designation"], list)
-        await client.aclose()
+        async with AsyncHttpClient() as client:
+            context = AdapterContext(fake_ledger)
+            mesh = MeSHAdapter(context, client, bootstrap_records=[mesh_descriptor()])
+            umls = UMLSAdapter(context, client, bootstrap_records=[umls_record()])
+            loinc = LoincAdapter(context, client, bootstrap_records=[loinc_record()])
+            icd = Icd11Adapter(context, client, bootstrap_records=[icd11_record()])
+            snomed = SnomedAdapter(context, client, bootstrap_records=[snomed_record()])
+            rxnorm = RxNormAdapter(context, client, bootstrap_records=[rxnav_properties()])
+
+            results = await asyncio.gather(
+                mesh.run(descriptor_id="D012345"),
+                umls.run(cui="C1234567"),
+                loinc.run(code="4548-4"),
+                icd.run(code="1A00"),
+                snomed.run(code="44054006"),
+                rxnorm.run(rxcui="12345"),
+            )
+
+            assert results[0][0].document.metadata["descriptor_id"].startswith("D")
+            assert isinstance(results[0][0].document.raw, dict)
+            assert results[1][0].document.metadata["cui"].startswith("C")
+            assert isinstance(results[1][0].document.raw, dict)
+            assert results[2][0].document.metadata["code"].endswith("-4")
+            assert isinstance(results[2][0].document.raw, dict)
+            assert results[5][0].document.metadata["rxcui"].isdigit()
+            assert isinstance(results[3][0].document.raw["title"], str)
+            assert isinstance(results[4][0].document.raw["designation"], list)

     _run(_test())


 def test_terminology_validations(fake_ledger: Any) -> None:
-    client = AsyncHttpClient()
-    context = AdapterContext(fake_ledger)
-    document = Document("doc", "mesh", "")
-
-    mesh = MeSHAdapter(context, client, bootstrap_records=[mesh_descriptor()])
-    document.metadata = {"descriptor_id": "BAD"}
-    with pytest.raises(ValueError):
-        mesh.validate(document)
-
-    umls = UMLSAdapter(context, client, bootstrap_records=[umls_record()])
-    document.metadata = {"cui": "BAD"}
-    with pytest.raises(ValueError):
-        umls.validate(document)
-
-    loinc = LoincAdapter(context, client, bootstrap_records=[loinc_record()])
-    document.metadata = {"code": "BAD"}
-    with pytest.raises(ValueError):
-        loinc.validate(document)
-
-    icd = Icd11Adapter(context, client, bootstrap_records=[icd11_record()])
-    with pytest.raises(ValueError):
-        icd.validate(Document("doc", "icd", "", metadata={"code": "X"}, raw={}))
-
-    snomed = SnomedAdapter(context, client, bootstrap_records=[snomed_record()])
-    with pytest.raises(ValueError):
-        snomed.validate(
-            Document("doc", "snomed", "", metadata={"code": "12"}, raw={"designation": []})
-        )
+    async def _test() -> None:
+        async with AsyncHttpClient() as client:
+            context = AdapterContext(fake_ledger)
+            document = Document("doc", "mesh", "")
+
+            mesh = MeSHAdapter(context, client, bootstrap_records=[mesh_descriptor()])
+            document.metadata = {"descriptor_id": "BAD"}
+            with pytest.raises(ValueError):
+                mesh.validate(document)
+
+            umls = UMLSAdapter(context, client, bootstrap_records=[umls_record()])
+            document.metadata = {"cui": "BAD"}
+            with pytest.raises(ValueError):
+                umls.validate(document)
+
+            loinc = LoincAdapter(context, client, bootstrap_records=[loinc_record()])
+            document.metadata = {"code": "BAD"}
+            with pytest.raises(ValueError):
+                loinc.validate(document)
+
+            icd = Icd11Adapter(context, client, bootstrap_records=[icd11_record()])
+            with pytest.raises(ValueError):
+                icd.validate(Document("doc", "icd", "", metadata={"code": "X"}, raw={}))
+
+            snomed = SnomedAdapter(context, client, bootstrap_records=[snomed_record()])
+            with pytest.raises(ValueError):
+                snomed.validate(
+                    Document(
+                        "doc", "snomed", "", metadata={"code": "12"}, raw={"designation": []}
+                    )
+                )

-    _run(client.aclose())
+    _run(_test())


 def test_literature_optional_field_variants(fake_ledger: Any) -> None:
     context = AdapterContext(fake_ledger)
     stub_client = _stub_http_client()

     pubmed = PubMedAdapter(context, stub_client)
     optional_pubmed = pubmed.parse(pubmed_document_with_optional_fields())
     assert isinstance(optional_pubmed.raw, dict)
     assert optional_pubmed.raw.get("pmcid") == "PMC1234567"
     assert optional_pubmed.raw.get("doi") == "10.1000/example.doi"
     minimal_pubmed = pubmed.parse(pubmed_document_without_optional_fields())
     assert isinstance(minimal_pubmed.raw, dict)
     assert minimal_pubmed.raw.get("pmcid") is None
     assert minimal_pubmed.raw.get("doi") is None

     medrxiv = MedRxivAdapter(context, stub_client)
     medrxiv_missing = medrxiv.parse(medrxiv_record_without_date())
     assert isinstance(medrxiv_missing.raw, dict)
     assert medrxiv_missing.raw.get("date") is None
     medrxiv_present = medrxiv.parse(medrxiv_record())
     assert isinstance(medrxiv_present.raw, dict)
     assert medrxiv_present.raw.get("date") is not None


@@ -790,64 +797,63 @@ def test_literature_fallback_returns_first_success() -> None:
     second = _FakeAdapter("pubmed", [document], raises=False)
     third = _FakeAdapter("medrxiv", [document], raises=False)
     fallback = LiteratureFallback(first, second, third)
     docs, source = _run(fallback.run())
     assert source == "pubmed"
     assert docs == [document]
     assert first.calls == 1 and second.calls == 1 and third.calls == 0


 def test_literature_fallback_raises_when_all_fail() -> None:
     class _Failing:
         source = "pmc"

         async def run(self, **_: Any) -> list[SimpleNamespace]:
             raise RuntimeError("boom")

     fallback = LiteratureFallback(_Failing(), _Failing())
     with pytest.raises(LiteratureFallbackError):
         _run(fallback.run())


 def test_terminology_adapters_cache_responses(
     fake_ledger: Any, monkeypatch: pytest.MonkeyPatch
 ) -> None:
     async def _test() -> None:
-        client = AsyncHttpClient()
-        adapter = MeSHAdapter(AdapterContext(fake_ledger), client)
-        calls = 0
-
-        async def fake_fetch_json(*_: Any, **__: Any) -> dict[str, Any]:
-            nonlocal calls
-            calls += 1
-            return mesh_descriptor()
-
-        monkeypatch.setattr(adapter, "fetch_json", fake_fetch_json)
-        await adapter.run(descriptor_id="D012345")
-        await adapter.run(descriptor_id="D012345")
-        assert calls == 1
-        await client.aclose()
+        async with AsyncHttpClient() as client:
+            adapter = MeSHAdapter(AdapterContext(fake_ledger), client)
+            calls = 0
+
+            async def fake_fetch_json(*_: Any, **__: Any) -> dict[str, Any]:
+                nonlocal calls
+                calls += 1
+                return mesh_descriptor()
+
+            monkeypatch.setattr(adapter, "fetch_json", fake_fetch_json)
+            await adapter.run(descriptor_id="D012345")
+            await adapter.run(descriptor_id="D012345")
+            assert calls == 1

     _run(_test())


 def test_udi_validator() -> None:
     assert UdiValidator.validate("00380740000011") is True
     assert UdiValidator.validate("12345678901234") is False


 class _FailingAdapter(BaseAdapter):
     source = "fail"

     async def fetch(self, *_: Any, **__: Any) -> AsyncIterator[Mapping[str, Any]]:
         yield {"id": "1"}

     def parse(self, raw: Mapping[str, Any]) -> Document:
         return Document("doc-1", self.source, "", raw=raw, metadata={})

     def validate(self, document: Document) -> None:
         raise RuntimeError("boom")


 class _SuccessfulAdapter(BaseAdapter):
     source = "success"

diff --git a/tests/ingestion/test_http_client.py b/tests/ingestion/test_http_client.py
index 052e2b444bda038acf55137c708d2729d19e3c06..efca33cc453255d0d2d79955e487a40e123a890b 100644
--- a/tests/ingestion/test_http_client.py
+++ b/tests/ingestion/test_http_client.py
@@ -6,208 +6,277 @@ from typing import Any, Sequence

 import pytest

 from Medical_KG.ingestion.http_client import AsyncHttpClient, RateLimit
 from Medical_KG.utils.optional_dependencies import (
     HttpxAsyncClient,
     HttpxModule,
     HttpxRequestProtocol,
     HttpxResponseProtocol,
     get_httpx_module,
 )

 HTTPX: HttpxModule = get_httpx_module()


 class _MockTransport:
     def __init__(self, responses: Sequence[HttpxResponseProtocol]) -> None:
         self._responses = list(responses)
         self.calls: list[str] = []

     async def handle_async_request(self, request: HttpxRequestProtocol) -> HttpxResponseProtocol:
         self.calls.append(str(request.url))
         return self._responses.pop(0)


+def test_async_context_manager_closes_client(monkeypatch: Any) -> None:
+    client = AsyncHttpClient()
+    closed = False
+    original_aclose = client._client.aclose
+
+    async def _aclose() -> None:
+        nonlocal closed
+        closed = True
+        await original_aclose()
+
+    monkeypatch.setattr(client._client, "aclose", _aclose)
+
+    async def _run() -> None:
+        async with client:
+            assert isinstance(client, AsyncHttpClient)
+
+    asyncio.run(_run())
+    assert closed is True
+
+
+def test_async_context_manager_closes_on_exception(monkeypatch: Any) -> None:
+    client = AsyncHttpClient()
+    closed = False
+    original_aclose = client._client.aclose
+
+    async def _aclose() -> None:
+        nonlocal closed
+        closed = True
+        await original_aclose()
+
+    monkeypatch.setattr(client._client, "aclose", _aclose)
+
+    async def _run() -> None:
+        async with client:
+            raise RuntimeError("boom")
+
+    with pytest.raises(RuntimeError):
+        asyncio.run(_run())
+    assert closed is True
+
+
+def test_nested_context_managers_close_in_reverse_order(monkeypatch: Any) -> None:
+    outer = AsyncHttpClient()
+    inner = AsyncHttpClient()
+    order: list[str] = []
+
+    outer_original = outer._client.aclose
+    inner_original = inner._client.aclose
+
+    async def _outer_close() -> None:
+        order.append("outer")
+        await outer_original()
+
+    async def _inner_close() -> None:
+        order.append("inner")
+        await inner_original()
+
+    monkeypatch.setattr(outer._client, "aclose", _outer_close)
+    monkeypatch.setattr(inner._client, "aclose", _inner_close)
+
+    async def _run() -> None:
+        async with outer:
+            async with inner:
+                assert True
+
+    asyncio.run(_run())
+    assert order == ["inner", "outer"]
+
+
 def test_http_client_uses_mock_transport(httpx_mock_transport: Any) -> None:
     def handler(request: HttpxRequestProtocol) -> HttpxResponseProtocol:
         assert request.method == "GET"
         return HTTPX.Response(
             status_code=200,
             json={"ok": True},
             request=request,
         )

     httpx_mock_transport(handler)
-    client = AsyncHttpClient()
-
     async def _run() -> None:
-        payload = await client.get_json("https://example.com")
-        assert payload.data["ok"] is True
+        async with AsyncHttpClient() as client:
+            payload = await client.get_json("https://example.com")
+            assert payload.data["ok"] is True

     asyncio.run(_run())
-    asyncio.run(client.aclose())


 def test_retry_on_transient_failure(monkeypatch: Any) -> None:
     responses = [
         HTTPX.Response(status_code=502, request=HTTPX.Request("GET", "https://example.com")),
         HTTPX.Response(
             status_code=200,
             request=HTTPX.Request("GET", "https://example.com"),
             json={"ok": True},
         ),
     ]
     transport = _MockTransport(responses)

     async def _request(
         self: HttpxAsyncClient, method: str, url: str, **kwargs: Any
     ) -> HttpxResponseProtocol:
         return await transport.handle_async_request(HTTPX.Request(method, url, **kwargs))

     client = AsyncHttpClient(retries=2, limits={"example.com": RateLimit(rate=5, per=1)})
     monkeypatch.setattr(
         client._client, "request", _request.__get__(client._client, HTTPX.AsyncClient)
     )

-    payload = asyncio.run(client.get_json("https://example.com"))
+    async def _run() -> Any:
+        async with client:
+            return await client.get_json("https://example.com")
+
+    payload = asyncio.run(_run())
     assert payload.data == {"ok": True}
     assert len(transport.calls) == 2
-    asyncio.run(client.aclose())


 def test_rate_limiter_serializes_calls(monkeypatch: Any) -> None:
     calls: list[float] = []

     async def _request(
         self: HttpxAsyncClient, method: str, url: str, **kwargs: Any
     ) -> HttpxResponseProtocol:
         calls.append(asyncio.get_running_loop().time())
         return HTTPX.Response(
             status_code=200,
             json={"ok": True},
             request=HTTPX.Request(method, url, **kwargs),
         )

     client = AsyncHttpClient(limits={"example.com": RateLimit(rate=1, per=0.5)})
     monkeypatch.setattr(
         client._client, "request", _request.__get__(client._client, HTTPX.AsyncClient)
     )

     async def _run() -> None:
-        await asyncio.gather(*(client.get_json("https://example.com") for _ in range(3)))
+        async with client:
+            await asyncio.gather(*(client.get_json("https://example.com") for _ in range(3)))

     asyncio.run(_run())
     assert len(calls) == 3
     assert all(b >= a for a, b in zip(calls, calls[1:]))
-    asyncio.run(client.aclose())


 def test_timeout_propagates(monkeypatch: Any) -> None:
     async def _request(
         self: HttpxAsyncClient, method: str, url: str, **kwargs: Any
     ) -> HttpxResponseProtocol:
         raise HTTPX.TimeoutException("timeout")

     client = AsyncHttpClient()
     monkeypatch.setattr(
         client._client, "request", _request.__get__(client._client, HTTPX.AsyncClient)
     )

     async def _call() -> None:
-        await client.get_json("https://example.com")
+        async with client:
+            await client.get_json("https://example.com")

     with pytest.raises(HTTPX.TimeoutException):
         asyncio.run(_call())
-    asyncio.run(client.aclose())


 def test_get_text_and_bytes(monkeypatch: Any) -> None:
     async def _request(
         self: HttpxAsyncClient, method: str, url: str, **kwargs: Any
     ) -> HttpxResponseProtocol:
         return HTTPX.Response(
             status_code=200,
             content=b"payload",
             request=HTTPX.Request(method, url, **kwargs),
         )

     client = AsyncHttpClient()
     monkeypatch.setattr(
         client._client, "request", _request.__get__(client._client, HTTPX.AsyncClient)
     )

     async def _run() -> None:
-        text = await client.get_text("https://example.com")
-        content = await client.get_bytes("https://example.com")
-        assert text.text == "payload"
-        assert content.content == b"payload"
+        async with client:
+            text = await client.get_text("https://example.com")
+            content = await client.get_bytes("https://example.com")
+            assert text.text == "payload"
+            assert content.content == b"payload"

     asyncio.run(_run())
-    asyncio.run(client.aclose())


 def test_post_uses_execute(monkeypatch: Any) -> None:
     async def _request(
         self: HttpxAsyncClient, method: str, url: str, **kwargs: Any
     ) -> HttpxResponseProtocol:
         assert method == "POST"
         assert kwargs["json"] == {"value": 1}
         return HTTPX.Response(
             status_code=200, json={"ok": True}, request=HTTPX.Request(method, url, **kwargs)
         )

     client = AsyncHttpClient()
     monkeypatch.setattr(
         client._client, "request", _request.__get__(client._client, HTTPX.AsyncClient)
     )

     async def _run() -> None:
-        response = await client.post("https://example.com", json={"value": 1})
-        assert response.json()["ok"] is True
+        async with client:
+            response = await client.post("https://example.com", json={"value": 1})
+            assert response.json()["ok"] is True

     asyncio.run(_run())
-    asyncio.run(client.aclose())
-    asyncio.run(client.aclose())


 def test_stream_context_manager(monkeypatch: Any) -> None:
     response = HTTPX.Response(
         status_code=200,
         content=b"stream",
         request=HTTPX.Request("GET", "https://example.com"),
         extensions={"elapsed": timedelta(0)},
     )
     response._elapsed = timedelta(0)  # type: ignore[attr-defined]

     class _Stream:
         async def __aenter__(self) -> HttpxResponseProtocol:
             return response

         async def __aexit__(self, *_exc: Any) -> None:
             return None

     def _stream(self: HttpxAsyncClient, method: str, url: str, **kwargs: Any) -> Any:
         assert method == "GET"
         return _Stream()

     client = AsyncHttpClient()
     monkeypatch.setattr(
         client._client, "stream", _stream.__get__(client._client, HTTPX.AsyncClient)
     )

     async def _run() -> None:
-        async with client.stream("GET", "https://example.com") as resp:
-            assert resp.content == b"stream"
+        async with client:
+            async with client.stream("GET", "https://example.com") as resp:
+                assert resp.content == b"stream"

     asyncio.run(_run())
-    asyncio.run(client.aclose())


 def test_set_rate_limit_resets_existing_limiter() -> None:
     client = AsyncHttpClient(limits={"example.com": RateLimit(rate=1, per=1.0)})
     first = client._get_limiter("example.com")
     client.set_rate_limit("example.com", RateLimit(rate=5, per=2.0))
     second = client._get_limiter("example.com")
     assert first is not second
     assert second.rate == 5
     asyncio.run(client.aclose())
diff --git a/tests/ingestion/test_ingest_cli.py b/tests/ingestion/test_ingest_cli.py
index 6cfddc145f521afcf26d167330603b9b3b747a38..bf0002627095acb3eec6e4637718c8af5f69427d 100644
--- a/tests/ingestion/test_ingest_cli.py
+++ b/tests/ingestion/test_ingest_cli.py
@@ -11,29 +11,35 @@ def test_ingest_cli_batch(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> No
     batch = tmp_path / "batch.ndjson"
     batch.write_text(json.dumps({"term": "lactate"}))
     ledger = tmp_path / "ledger.jsonl"

     parser = build_parser()
     args = parser.parse_args(
         [
             "ingest",
             "pubmed",
             "--batch",
             str(batch),
             "--auto",
             "--ledger",
             str(ledger),
         ]
     )

     class DummyAdapter:
         async def run(self, **kwargs: Any) -> list[object]:
             return []

     class DummyClient:
         async def aclose(self) -> None:
             return None

+        async def __aenter__(self) -> "DummyClient":
+            return self
+
+        async def __aexit__(self, *_exc: Any) -> bool:
+            return False
+
     monkeypatch.setattr("Medical_KG.cli.get_adapter", lambda *args, **kwargs: DummyAdapter())
     monkeypatch.setattr("Medical_KG.cli.AsyncHttpClient", lambda: DummyClient())
     result = args.func(args)
     assert result == 0
diff --git a/tests/ingestion/test_registry.py b/tests/ingestion/test_registry.py
index 0b0dbadc43b7e90b865e22063c82a07e71468185..4804a10075a0ce5ab079d85119b5a5941c667fac 100644
--- a/tests/ingestion/test_registry.py
+++ b/tests/ingestion/test_registry.py
@@ -3,37 +3,41 @@ from __future__ import annotations
 import asyncio
 from pathlib import Path

 import pytest

 from Medical_KG.ingestion import registry
 from Medical_KG.ingestion.adapters.base import AdapterContext
 from Medical_KG.ingestion.http_client import AsyncHttpClient
 from Medical_KG.ingestion.ledger import IngestionLedger


 def _ledger_path(tmp_path: Path) -> Path:
     target_dir = tmp_path / "ledger"
     target_dir.mkdir()
     return target_dir / "ledger.jsonl"


 def test_available_sources_sorted() -> None:
     sources = registry.available_sources()
     assert sources == sorted(sources)
     assert "pubmed" in sources


 def test_get_adapter_returns_instance(tmp_path: Path) -> None:
     ledger = IngestionLedger(_ledger_path(tmp_path))
-    client = AsyncHttpClient()
-    adapter = registry.get_adapter("pubmed", AdapterContext(ledger=ledger), client)
-    assert adapter.source == "pubmed"
-    asyncio.run(client.aclose())
+    async def _build() -> str:
+        async with AsyncHttpClient() as client:
+            adapter = registry.get_adapter("pubmed", AdapterContext(ledger=ledger), client)
+            return adapter.source
+
+    assert asyncio.run(_build()) == "pubmed"


 def test_get_adapter_unknown_source(tmp_path: Path) -> None:
     ledger = IngestionLedger(_ledger_path(tmp_path))
-    client = AsyncHttpClient()
+    async def _call() -> None:
+        async with AsyncHttpClient() as client:
+            registry.get_adapter("unknown", AdapterContext(ledger=ledger), client)
+
     with pytest.raises(ValueError):
-        registry.get_adapter("unknown", AdapterContext(ledger=ledger), client)
-    asyncio.run(client.aclose())
+        asyncio.run(_call())

EOF
)
